{"version":3,"file":"scrolling.js","sources":["../../../src/cdk/scrolling/index.ts","../../../src/cdk/scrolling/public_api.ts","../../../src/cdk/scrolling/viewport-ruler.ts","../../../src/cdk/scrolling/scrollable.ts","../../../src/cdk/scrolling/scroll-dispatcher.ts"],"sourcesContent":["/**\n * Generated bundle index. Do not edit.\n */\n\nexport {ScrollDispatchModule,DEFAULT_SCROLL_TIME,ScrollDispatcher,SCROLL_DISPATCHER_PROVIDER_FACTORY,SCROLL_DISPATCHER_PROVIDER,Scrollable,ViewportRuler,VIEWPORT_RULER_PROVIDER_FACTORY,VIEWPORT_RULER_PROVIDER} from './public_api';\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {NgModule} from '@angular/core';\r\nimport {SCROLL_DISPATCHER_PROVIDER} from './scroll-dispatcher';\r\nimport {Scrollable} from './scrollable';\r\nimport {PlatformModule} from '@angular/cdk/platform';\nexport class ScrollDispatchModule {static decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{\r\n  imports: [PlatformModule],\r\n  exports: [Scrollable],\r\n  declarations: [Scrollable],\r\n  providers: [SCROLL_DISPATCHER_PROVIDER],\r\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction ScrollDispatchModule_tsickle_Closure_declarations() {\n/** @type {?} */\nScrollDispatchModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nScrollDispatchModule.ctorParameters;\n}\n\r\n\r\nexport {DEFAULT_SCROLL_TIME,ScrollDispatcher,SCROLL_DISPATCHER_PROVIDER_FACTORY,SCROLL_DISPATCHER_PROVIDER} from './scroll-dispatcher';\r\nexport {Scrollable} from './scrollable';\r\nexport {ViewportRuler,VIEWPORT_RULER_PROVIDER_FACTORY,VIEWPORT_RULER_PROVIDER} from './viewport-ruler';\r\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {Injectable, Optional, SkipSelf} from '@angular/core';\r\nimport {ScrollDispatcher} from './scroll-dispatcher';\n/**\n * Simple utility for getting the bounds of the browser viewport.\r\\@docs-private\n */\nexport class ViewportRuler {\n/**\n * Cached document client rectangle.\n */\nprivate _documentRect?: ClientRect;\n/**\n * @param {?} scrollDispatcher\n */\nconstructor(scrollDispatcher: ScrollDispatcher) {\r\n    // Subscribe to scroll and resize events and update the document rectangle on changes.\r\n    scrollDispatcher.scrolled(0, () => this._cacheViewportGeometry());\r\n  }\n/**\n * Gets a ClientRect for the viewport's bounds.\n * @param {?=} documentRect\n * @return {?}\n */\ngetViewportRect(documentRect = this._documentRect): ClientRect {\r\n    // Cache the document bounding rect so that we don't recompute it for multiple calls.\r\n    if (!documentRect) {\r\n      this._cacheViewportGeometry();\r\n      documentRect = this._documentRect;\r\n    }\r\n\r\n    // Use the document element's bounding rect rather than the window scroll properties\r\n    // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\r\n    // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\r\n    // conceptual viewports. Under most circumstances these viewports are equivalent, but they\r\n    // can disagree when the page is pinch-zoomed (on devices that support touch).\r\n    // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\r\n    // We use the documentElement instead of the body because, by default (without a css reset)\r\n    // browsers typically give the document body an 8px margin, which is not included in\r\n    // getBoundingClientRect().\r\n    const /** @type {?} */ scrollPosition = this.getViewportScrollPosition(documentRect);\r\n    const /** @type {?} */ height = window.innerHeight;\r\n    const /** @type {?} */ width = window.innerWidth;\r\n\r\n    return {\r\n      top: scrollPosition.top,\r\n      left: scrollPosition.left,\r\n      bottom: scrollPosition.top + height,\r\n      right: scrollPosition.left + width,\r\n      height,\r\n      width,\r\n    };\r\n  }\n/**\n * Gets the (top, left) scroll position of the viewport.\r\\@param documentRect\n * @param {?=} documentRect\n * @return {?}\n */\ngetViewportScrollPosition(documentRect = this._documentRect) {\r\n    // Cache the document bounding rect so that we don't recompute it for multiple calls.\r\n    if (!documentRect) {\r\n      this._cacheViewportGeometry();\r\n      documentRect = this._documentRect;\r\n    }\r\n\r\n    // The top-left-corner of the viewport is determined by the scroll position of the document\r\n    // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\r\n    // whether `document.body` or `document.documentElement` is the scrolled element, so reading\r\n    // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\r\n    // `document.documentElement` works consistently, where the `top` and `left` values will\r\n    // equal negative the scroll position.\r\n    const /** @type {?} */ top = - /** @type {?} */((documentRect)).top || document.body.scrollTop || window.scrollY ||\r\n                  document.documentElement.scrollTop || 0;\r\n\r\n    const /** @type {?} */ left = - /** @type {?} */((documentRect)).left || document.body.scrollLeft || window.scrollX ||\r\n                  document.documentElement.scrollLeft || 0;\r\n\r\n    return {top, left};\r\n  }\n/**\n * Caches the latest client rectangle of the document element.\n * @return {?}\n */\n_cacheViewportGeometry() {\r\n    this._documentRect = document.documentElement.getBoundingClientRect();\r\n  }\r\n\r\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ScrollDispatcher, },\n];\n}\n\nfunction ViewportRuler_tsickle_Closure_declarations() {\n/** @type {?} */\nViewportRuler.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nViewportRuler.ctorParameters;\n/**\n * Cached document client rectangle.\n * @type {?}\n */\nViewportRuler.prototype._documentRect;\n}\n\n/**\n * \\@docs-private\n * @param {?} parentRuler\n * @param {?} scrollDispatcher\n * @return {?}\n */\nexport function VIEWPORT_RULER_PROVIDER_FACTORY(parentRuler: ViewportRuler,\r\n                                                scrollDispatcher: ScrollDispatcher) {\r\n  return parentRuler || new ViewportRuler(scrollDispatcher);\r\n}\n/**\n * \\@docs-private\n */\nexport const VIEWPORT_RULER_PROVIDER = {\r\n  // If there is already a ViewportRuler available, use that. Otherwise, provide a new one.\r\n  provide: ViewportRuler,\r\n  deps: [[new Optional(), new SkipSelf(), ViewportRuler], ScrollDispatcher],\r\n  useFactory: VIEWPORT_RULER_PROVIDER_FACTORY\r\n};\r\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {Directive, ElementRef, OnInit, OnDestroy, NgZone, Renderer2} from '@angular/core';\r\nimport {Observable} from 'rxjs/Observable';\r\nimport {Subject} from 'rxjs/Subject';\r\nimport {ScrollDispatcher} from './scroll-dispatcher';\n/**\n * Sends an event when the directive's element is scrolled. Registers itself with the\rScrollDispatcher service to include itself as part of its collection of scrolling events that it\rcan be listened to through the service.\n */\nexport class Scrollable implements OnInit, OnDestroy {\nprivate _elementScrolled: Subject<Event> = new Subject();\nprivate _scrollListener: Function | null;\n/**\n * @param {?} _elementRef\n * @param {?} _scroll\n * @param {?} _ngZone\n * @param {?} _renderer\n */\nconstructor(private _elementRef: ElementRef,\nprivate _scroll: ScrollDispatcher,\nprivate _ngZone: NgZone,\nprivate _renderer: Renderer2) {}\n/**\n * @return {?}\n */\nngOnInit() {\r\n    this._scrollListener = this._ngZone.runOutsideAngular(() => {\r\n      return this._renderer.listen(this.getElementRef().nativeElement, 'scroll', (event: Event) => {\r\n        this._elementScrolled.next(event);\r\n      });\r\n    });\r\n\r\n    this._scroll.register(this);\r\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\r\n    this._scroll.deregister(this);\r\n\r\n    if (this._scrollListener) {\r\n      this._scrollListener();\r\n      this._scrollListener = null;\r\n    }\r\n  }\n/**\n * Returns observable that emits when a scroll event is fired on the host element.\n * @return {?}\n */\nelementScrolled(): Observable<any> {\r\n    return this._elementScrolled.asObservable();\r\n  }\n/**\n * @return {?}\n */\ngetElementRef(): ElementRef {\r\n    return this._elementRef;\r\n  }\r\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{\r\n  selector: '[cdk-scrollable], [cdkScrollable]'\r\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ElementRef, },\n{type: ScrollDispatcher, },\n{type: NgZone, },\n{type: Renderer2, },\n];\n}\n\nfunction Scrollable_tsickle_Closure_declarations() {\n/** @type {?} */\nScrollable.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nScrollable.ctorParameters;\n/** @type {?} */\nScrollable.prototype._elementScrolled;\n/** @type {?} */\nScrollable.prototype._scrollListener;\n/** @type {?} */\nScrollable.prototype._elementRef;\n/** @type {?} */\nScrollable.prototype._scroll;\n/** @type {?} */\nScrollable.prototype._ngZone;\n/** @type {?} */\nScrollable.prototype._renderer;\n}\n\r\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {ElementRef, Injectable, NgZone, Optional, SkipSelf} from '@angular/core';\r\nimport {Platform} from '@angular/cdk/platform';\r\nimport {Subject} from 'rxjs/Subject';\r\nimport {Subscription} from 'rxjs/Subscription';\r\nimport {fromEvent} from 'rxjs/observable/fromEvent';\r\nimport {merge} from 'rxjs/observable/merge';\r\nimport {auditTime} from 'rxjs/operator/auditTime';\r\nimport {Scrollable} from './scrollable';\n/**\n * Time in ms to throttle the scrolling events by default.\n */\nexport const DEFAULT_SCROLL_TIME = 20;\n/**\n * Service contained all registered Scrollable references and emits an event when any one of the\rScrollable references emit a scrolled event.\n */\nexport class ScrollDispatcher {\n/**\n * @param {?} _ngZone\n * @param {?} _platform\n */\nconstructor(private _ngZone: NgZone,\nprivate _platform: Platform) { }\n/**\n * Subject for notifying that a registered scrollable reference element has been scrolled.\n */\n_scrolled: Subject<void> = new Subject<void>();\n/**\n * Keeps track of the global `scroll` and `resize` subscriptions.\n */\n_globalSubscription: Subscription | null = null;\n/**\n * Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards.\n */\nprivate _scrolledCount = 0;\n/**\n * Map of all the scrollable references that are registered with the service and their\rscroll event subscriptions.\n */\nscrollableReferences: Map<Scrollable, Subscription> = new Map();\n/**\n * Registers a Scrollable with the service and listens for its scrolled events. When the\rscrollable is scrolled, the service emits the event in its scrolled observable.\r\\@param scrollable Scrollable instance to be registered.\n * @param {?} scrollable\n * @return {?}\n */\nregister(scrollable: Scrollable): void {\r\n    const /** @type {?} */ scrollSubscription = scrollable.elementScrolled().subscribe(() => this._notify());\r\n\r\n    this.scrollableReferences.set(scrollable, scrollSubscription);\r\n  }\n/**\n * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\r\\@param scrollable Scrollable instance to be deregistered.\n * @param {?} scrollable\n * @return {?}\n */\nderegister(scrollable: Scrollable): void {\r\n    const /** @type {?} */ scrollableReference = this.scrollableReferences.get(scrollable);\r\n\r\n    if (scrollableReference) {\r\n      scrollableReference.unsubscribe();\r\n      this.scrollableReferences.delete(scrollable);\r\n    }\r\n  }\n/**\n * Subscribes to an observable that emits an event whenever any of the registered Scrollable\rreferences (or window, document, or body) fire a scrolled event. Can provide a time in ms\rto override the default \"throttle\" time.\n * @param {?=} auditTimeInMs\n * @param {?=} callback\n * @return {?}\n */\nscrolled(auditTimeInMs: number = DEFAULT_SCROLL_TIME, callback: () => any): Subscription {\r\n    // Scroll events can only happen on the browser, so do nothing if we're not on the browser.\r\n    if (!this._platform.isBrowser) {\r\n      return Subscription.EMPTY;\r\n    }\r\n\r\n    // In the case of a 0ms delay, use an observable without auditTime\r\n    // since it does add a perceptible delay in processing overhead.\r\n    let /** @type {?} */ observable = auditTimeInMs > 0 ?\r\n      auditTime.call(this._scrolled.asObservable(), auditTimeInMs) :\r\n      this._scrolled.asObservable();\r\n\r\n    this._scrolledCount++;\r\n\r\n    if (!this._globalSubscription) {\r\n      this._globalSubscription = this._ngZone.runOutsideAngular(() => {\r\n        return merge(\r\n          fromEvent(window.document, 'scroll'),\r\n          fromEvent(window, 'resize')\r\n        ).subscribe(() => this._notify());\r\n      });\r\n    }\r\n\r\n    // Note that we need to do the subscribing from here, in order to be able to remove\r\n    // the global event listeners once there are no more subscriptions.\r\n    let /** @type {?} */ subscription = observable.subscribe(callback);\r\n\r\n    subscription.add(() => {\r\n      this._scrolledCount--;\r\n\r\n      if (this._globalSubscription && !this.scrollableReferences.size && !this._scrolledCount) {\r\n        this._globalSubscription.unsubscribe();\r\n        this._globalSubscription = null;\r\n      }\r\n    });\r\n\r\n    return subscription;\r\n  }\n/**\n * Returns all registered Scrollables that contain the provided element.\n * @param {?} elementRef\n * @return {?}\n */\ngetScrollContainers(elementRef: ElementRef): Scrollable[] {\r\n    const /** @type {?} */ scrollingContainers: Scrollable[] = [];\r\n\r\n    this.scrollableReferences.forEach((_subscription: Subscription, scrollable: Scrollable) => {\r\n      if (this.scrollableContainsElement(scrollable, elementRef)) {\r\n        scrollingContainers.push(scrollable);\r\n      }\r\n    });\r\n\r\n    return scrollingContainers;\r\n  }\n/**\n * Returns true if the element is contained within the provided Scrollable.\n * @param {?} scrollable\n * @param {?} elementRef\n * @return {?}\n */\nscrollableContainsElement(scrollable: Scrollable, elementRef: ElementRef): boolean {\r\n    let /** @type {?} */ element = elementRef.nativeElement;\r\n    let /** @type {?} */ scrollableElement = scrollable.getElementRef().nativeElement;\r\n\r\n    // Traverse through the element parents until we reach null, checking if any of the elements\r\n    // are the scrollable's element.\r\n    do {\r\n      if (element == scrollableElement) { return true; }\r\n    } while (element = element.parentElement);\r\n\r\n    return false;\r\n  }\n/**\n * Sends a notification that a scroll event has been fired.\n * @return {?}\n */\n_notify() {\r\n    this._scrolled.next();\r\n  }\r\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: NgZone, },\n{type: Platform, },\n];\n}\n\nfunction ScrollDispatcher_tsickle_Closure_declarations() {\n/** @type {?} */\nScrollDispatcher.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nScrollDispatcher.ctorParameters;\n/**\n * Subject for notifying that a registered scrollable reference element has been scrolled.\n * @type {?}\n */\nScrollDispatcher.prototype._scrolled;\n/**\n * Keeps track of the global `scroll` and `resize` subscriptions.\n * @type {?}\n */\nScrollDispatcher.prototype._globalSubscription;\n/**\n * Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards.\n * @type {?}\n */\nScrollDispatcher.prototype._scrolledCount;\n/**\n * Map of all the scrollable references that are registered with the service and their\rscroll event subscriptions.\n * @type {?}\n */\nScrollDispatcher.prototype.scrollableReferences;\n/** @type {?} */\nScrollDispatcher.prototype._ngZone;\n/** @type {?} */\nScrollDispatcher.prototype._platform;\n}\n\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} ngZone\n * @param {?} platform\n * @return {?}\n */\nexport function SCROLL_DISPATCHER_PROVIDER_FACTORY(\r\n    parentDispatcher: ScrollDispatcher, ngZone: NgZone, platform: Platform) {\r\n  return parentDispatcher || new ScrollDispatcher(ngZone, platform);\r\n}\n/**\n * \\@docs-private\n */\nexport const SCROLL_DISPATCHER_PROVIDER = {\r\n  // If there is already a ScrollDispatcher available, use that. Otherwise, provide a new one.\r\n  provide: ScrollDispatcher,\r\n  deps: [[new Optional(), new SkipSelf(), ScrollDispatcher], NgZone, Platform],\r\n  useFactory: SCROLL_DISPATCHER_PROVIDER_FACTORY\r\n};\r\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"],"names":[],"mappings":"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"}