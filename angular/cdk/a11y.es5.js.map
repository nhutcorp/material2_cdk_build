{"version":3,"file":"a11y.es5.js","sources":["../../../src/cdk/a11y/index.ts","../../../src/cdk/a11y/public_api.ts","../../../src/cdk/a11y/focus-key-manager.ts","../../../src/cdk/a11y/activedescendant-key-manager.ts","../../../src/cdk/a11y/list-key-manager.ts","../../../src/cdk/a11y/fake-mousedown.ts","../../../src/cdk/a11y/live-announcer.ts","../../../src/cdk/a11y/focus-trap.ts","../../../src/cdk/a11y/interactivity-checker.ts"],"sourcesContent":["/**\n * Generated bundle index. Do not edit.\n */\n\nexport {A11yModule,LIVE_ANNOUNCER_ELEMENT_TOKEN,AriaLivePoliteness,LiveAnnouncer,LIVE_ANNOUNCER_PROVIDER_FACTORY,LIVE_ANNOUNCER_PROVIDER,isFakeMousedownFromScreenReader,FocusTrap,FocusTrapFactory,FocusTrapDeprecatedDirective,FocusTrapDirective,InteractivityChecker,ListKeyManagerOption,ListKeyManager,Highlightable,ActiveDescendantKeyManager,FocusableOption,FocusKeyManager} from './public_api';\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {NgModule} from '@angular/core';\r\nimport {FocusTrapDirective, FocusTrapDeprecatedDirective, FocusTrapFactory} from './focus-trap';\r\nimport {LIVE_ANNOUNCER_PROVIDER} from './live-announcer';\r\nimport {InteractivityChecker} from './interactivity-checker';\r\nimport {CommonModule} from '@angular/common';\r\nimport {PlatformModule} from '@angular/cdk/platform';\nexport class A11yModule {static decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{\r\n  imports: [CommonModule, PlatformModule],\r\n  declarations: [FocusTrapDirective, FocusTrapDeprecatedDirective],\r\n  exports: [FocusTrapDirective, FocusTrapDeprecatedDirective],\r\n  providers: [InteractivityChecker, FocusTrapFactory, LIVE_ANNOUNCER_PROVIDER]\r\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction A11yModule_tsickle_Closure_declarations() {\n/** @type {?} */\nA11yModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nA11yModule.ctorParameters;\n}\n\r\n\r\nexport {LIVE_ANNOUNCER_ELEMENT_TOKEN,AriaLivePoliteness,LiveAnnouncer,LIVE_ANNOUNCER_PROVIDER_FACTORY,LIVE_ANNOUNCER_PROVIDER} from './live-announcer';\r\nexport {isFakeMousedownFromScreenReader} from './fake-mousedown';\r\nexport {FocusTrap,FocusTrapFactory,FocusTrapDeprecatedDirective,FocusTrapDirective} from './focus-trap';\r\nexport {InteractivityChecker} from './interactivity-checker';\r\nexport {ListKeyManagerOption,ListKeyManager} from './list-key-manager';\r\nexport {Highlightable,ActiveDescendantKeyManager} from './activedescendant-key-manager';\r\nexport {FocusableOption,FocusKeyManager} from './focus-key-manager';\r\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {ListKeyManager, ListKeyManagerOption} from './list-key-manager';\r\n\r\n/**\r\n * This is the interface for focusable items (used by the FocusKeyManager).\r\n * Each item must know how to focus itself, whether or not it is currently disabled\r\n * and be able to supply it's label.\r\n */\r\nexport interface FocusableOption extends ListKeyManagerOption {\r\n  focus(): void;\r\n}\nexport class FocusKeyManager<T> extends ListKeyManager<FocusableOption & T> {\n/**\n * This method sets the active item to the item at the specified index.\rIt also adds focuses the newly active item.\n * @param {?} index\n * @return {?}\n */\nsetActiveItem(index: number): void {\r\n    super.setActiveItem(index);\r\n\r\n    if (this.activeItem) {\r\n      this.activeItem.focus();\r\n    }\r\n  }\r\n}\r\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {ListKeyManager, ListKeyManagerOption} from './list-key-manager';\r\n\r\n/**\r\n * This is the interface for highlightable items (used by the ActiveDescendantKeyManager).\r\n * Each item must know how to style itself as active or inactive and whether or not it is\r\n * currently disabled.\r\n */\r\nexport interface Highlightable extends ListKeyManagerOption {\r\n  setActiveStyles(): void;\r\n  setInactiveStyles(): void;\r\n}\nexport class ActiveDescendantKeyManager<T> extends ListKeyManager<Highlightable & T> {\n/**\n * This method sets the active item to the item at the specified index.\rIt also adds active styles to the newly active item and removes active\rstyles from the previously active item.\n * @param {?} index\n * @return {?}\n */\nsetActiveItem(index: number): void {\r\n    Promise.resolve().then(() => {\r\n      if (this.activeItem) {\r\n        this.activeItem.setInactiveStyles();\r\n      }\r\n      super.setActiveItem(index);\r\n      if (this.activeItem) {\r\n        this.activeItem.setActiveStyles();\r\n      }\r\n    });\r\n  }\r\n\r\n}\r\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {QueryList} from '@angular/core';\r\nimport {Subject} from 'rxjs/Subject';\r\nimport {Subscription} from 'rxjs/Subscription';\r\nimport {UP_ARROW, DOWN_ARROW, TAB, A, Z, ZERO, NINE} from '@angular/cdk/keycodes';\r\nimport {RxChain, debounceTime, filter, map, doOperator} from '@angular/cdk/rxjs';\r\n\r\n/**\r\n * This interface is for items that can be passed to a ListKeyManager.\r\n */\r\nexport interface ListKeyManagerOption {\r\n  disabled?: boolean;\r\n  getLabel?(): string;\r\n}\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\rof items, it will set the active item correctly when arrow events occur.\n */\nexport class ListKeyManager<T extends ListKeyManagerOption> {\nprivate _activeItemIndex = -1;\nprivate _activeItem: T;\nprivate _wrap = false;\nprivate _letterKeyStream = new Subject<string>();\nprivate _typeaheadSubscription = Subscription.EMPTY;\nprivate _pressedLetters: string[] = [];\n/**\n * @param {?} _items\n */\nconstructor(private _items: QueryList<T>) { }\n/**\n * Stream that emits any time the TAB key is pressed, so components can react\rwhen focus is shifted off of the list.\n */\ntabOut: Subject<void> = new Subject<void>();\n/**\n * Turns on wrapping mode, which ensures that the active item will wrap to\rthe other end of list when there are no more items in the given direction.\n * @return {?}\n */\nwithWrap(): this {\r\n    this._wrap = true;\r\n    return this;\r\n  }\n/**\n * Turns on typeahead mode which allows users to set the active item by typing.\r\\@param debounceInterval Time to wait after the last keystroke before setting the active item.\n * @param {?=} debounceInterval\n * @return {?}\n */\nwithTypeAhead(debounceInterval = 200): this {\r\n    if (this._items.length && this._items.some(item => typeof item.getLabel !== 'function')) {\r\n      throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\r\n    }\r\n\r\n    this._typeaheadSubscription.unsubscribe();\r\n\r\n    // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\r\n    // and convert those letters back into a string. Afterwards find the first item that starts\r\n    // with that string and select it.\r\n    this._typeaheadSubscription = RxChain.from(this._letterKeyStream)\r\n      .call(doOperator, keyCode => this._pressedLetters.push(keyCode))\r\n      .call(debounceTime, debounceInterval)\r\n      .call(filter, () => this._pressedLetters.length > 0)\r\n      .call(map, () => this._pressedLetters.join(''))\r\n      .subscribe(inputString => {\r\n        const /** @type {?} */ items = this._items.toArray();\r\n\r\n        for (let /** @type {?} */ i = 0; i < items.length; i++) {\r\n          if ( /** @type {?} */((items[i].getLabel))().toUpperCase().trim().indexOf(inputString) === 0) {\r\n            this.setActiveItem(i);\r\n            break;\r\n          }\r\n        }\r\n\r\n        this._pressedLetters = [];\r\n      });\r\n\r\n    return this;\r\n  }\n/**\n * Sets the active item to the item at the index specified.\r\\@param index The index of the item to be set as active.\n * @param {?} index\n * @return {?}\n */\nsetActiveItem(index: number): void {\r\n    this._activeItemIndex = index;\r\n    this._activeItem = this._items.toArray()[index];\r\n  }\n/**\n * Sets the active item depending on the key event passed in.\r\\@param event Keyboard event to be used for determining which element should be active.\n * @param {?} event\n * @return {?}\n */\nonKeydown(event: KeyboardEvent): void {\r\n    switch (event.keyCode) {\r\n      case DOWN_ARROW: this.setNextItemActive(); break;\r\n      case UP_ARROW: this.setPreviousItemActive(); break;\r\n      case TAB: this.tabOut.next(); return;\r\n      default:\r\n        const /** @type {?} */ keyCode = event.keyCode;\r\n\r\n        // Attempt to use the `event.key` which also maps it to the user's keyboard language,\r\n        // otherwise fall back to resolving alphanumeric characters via the keyCode.\r\n        if (event.key && event.key.length === 1) {\r\n          this._letterKeyStream.next(event.key.toLocaleUpperCase());\r\n        } else if ((keyCode >= A && keyCode <= Z) || (keyCode >= ZERO && keyCode <= NINE)) {\r\n          this._letterKeyStream.next(String.fromCharCode(keyCode));\r\n        }\r\n\r\n        // Note that we return here, in order to avoid preventing\r\n        // the default action of non-navigational keys.\r\n        return;\r\n    }\r\n\r\n    this._pressedLetters = [];\r\n    event.preventDefault();\r\n  }\n/**\n * Index of the currently active item.\n * @return {?}\n */\nget activeItemIndex(): number | null {\r\n    return this._activeItemIndex;\r\n  }\n/**\n * The active item.\n * @return {?}\n */\nget activeItem(): T | null {\r\n    return this._activeItem;\r\n  }\n/**\n * Sets the active item to the first enabled item in the list.\n * @return {?}\n */\nsetFirstItemActive(): void {\r\n    this._setActiveItemByIndex(0, 1);\r\n  }\n/**\n * Sets the active item to the last enabled item in the list.\n * @return {?}\n */\nsetLastItemActive(): void {\r\n    this._setActiveItemByIndex(this._items.length - 1, -1);\r\n  }\n/**\n * Sets the active item to the next enabled item in the list.\n * @return {?}\n */\nsetNextItemActive(): void {\r\n    this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\r\n  }\n/**\n * Sets the active item to a previous enabled item in the list.\n * @return {?}\n */\nsetPreviousItemActive(): void {\r\n    this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive()\r\n                                            : this._setActiveItemByDelta(-1);\r\n  }\n/**\n * Allows setting of the activeItemIndex without any other effects.\r\\@param index The new activeItemIndex.\n * @param {?} index\n * @return {?}\n */\nupdateActiveItemIndex(index: number) {\r\n    this._activeItemIndex = index;\r\n  }\n/**\n * This method sets the active item, given a list of items and the delta between the\rcurrently active item and the new active item. It will calculate differently\rdepending on whether wrap mode is turned on.\n * @param {?} delta\n * @param {?=} items\n * @return {?}\n */\nprivate _setActiveItemByDelta(delta: number, items = this._items.toArray()): void {\r\n    this._wrap ? this._setActiveInWrapMode(delta, items)\r\n               : this._setActiveInDefaultMode(delta, items);\r\n  }\n/**\n * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\rdown the list until it finds an item that is not disabled, and it will wrap if it\rencounters either end of the list.\n * @param {?} delta\n * @param {?} items\n * @return {?}\n */\nprivate _setActiveInWrapMode(delta: number, items: T[]): void {\r\n    // when active item would leave menu, wrap to beginning or end\r\n    this._activeItemIndex =\r\n      (this._activeItemIndex + delta + items.length) % items.length;\r\n\r\n    // skip all disabled menu items recursively until an enabled one is reached\r\n    if (items[this._activeItemIndex].disabled) {\r\n      this._setActiveInWrapMode(delta, items);\r\n    } else {\r\n      this.setActiveItem(this._activeItemIndex);\r\n    }\r\n  }\n/**\n * Sets the active item properly given the default mode. In other words, it will\rcontinue to move down the list until it finds an item that is not disabled. If\rit encounters either end of the list, it will stop and not wrap.\n * @param {?} delta\n * @param {?} items\n * @return {?}\n */\nprivate _setActiveInDefaultMode(delta: number, items: T[]): void {\r\n    this._setActiveItemByIndex(this._activeItemIndex + delta, delta, items);\r\n  }\n/**\n * Sets the active item to the first enabled item starting at the index specified. If the\ritem is disabled, it will move in the fallbackDelta direction until it either\rfinds an enabled item or encounters the end of the list.\n * @param {?} index\n * @param {?} fallbackDelta\n * @param {?=} items\n * @return {?}\n */\nprivate _setActiveItemByIndex(index: number, fallbackDelta: number,\r\n                                  items = this._items.toArray()): void {\r\n    if (!items[index]) { return; }\r\n    while (items[index].disabled) {\r\n      index += fallbackDelta;\r\n      if (!items[index]) { return; }\r\n    }\r\n    this.setActiveItem(index);\r\n  }\r\n}\n\nfunction ListKeyManager_tsickle_Closure_declarations() {\n/** @type {?} */\nListKeyManager.prototype._activeItemIndex;\n/** @type {?} */\nListKeyManager.prototype._activeItem;\n/** @type {?} */\nListKeyManager.prototype._wrap;\n/** @type {?} */\nListKeyManager.prototype._letterKeyStream;\n/** @type {?} */\nListKeyManager.prototype._typeaheadSubscription;\n/** @type {?} */\nListKeyManager.prototype._pressedLetters;\n/**\n * Stream that emits any time the TAB key is pressed, so components can react\rwhen focus is shifted off of the list.\n * @type {?}\n */\nListKeyManager.prototype.tabOut;\n/** @type {?} */\nListKeyManager.prototype._items;\n}\n\r\n","\n/**\n * Screenreaders will often fire fake mousedown events when a focusable element\ris activated using the keyboard. We can typically distinguish between these faked\rmousedown events and real mousedown events using the \"buttons\" property. While\rreal mousedowns will indicate the mouse button that was pressed (e.g. \"1\" for\rthe left mouse button), faked mousedowns will usually set the property value to 0.\n * @param {?} event\n * @return {?}\n */\nexport function isFakeMousedownFromScreenReader(event: MouseEvent): boolean {\r\n  return event.buttons === 0;\r\n}\r\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {\r\n  Injectable,\r\n  InjectionToken,\r\n  Optional,\r\n  Inject,\r\n  SkipSelf,\r\n  OnDestroy,\r\n} from '@angular/core';\r\nimport {Platform} from '@angular/cdk/platform';\r\n\r\n\r\nexport const /** @type {?} */ LIVE_ANNOUNCER_ELEMENT_TOKEN = new InjectionToken<HTMLElement>('liveAnnouncerElement');\r\n\r\n/** Possible politeness levels. */\r\nexport type AriaLivePoliteness = 'off' | 'polite' | 'assertive';\nexport class LiveAnnouncer implements OnDestroy {\nprivate _liveElement: Element;\n/**\n * @param {?} elementToken\n * @param {?} platform\n */\nconstructor(\r\n        elementToken: any,\r\n      platform: Platform) {\r\n    // Only do anything if we're on the browser platform.\r\n    if (platform.isBrowser) {\r\n      // We inject the live element as `any` because the constructor signature cannot reference\r\n      // browser globals (HTMLElement) on non-browser environments, since having a class decorator\r\n      // causes TypeScript to preserve the constructor signature types.\r\n      this._liveElement = elementToken || this._createLiveElement();\r\n    }\r\n  }\n/**\n * Announces a message to screenreaders.\r\\@param message Message to be announced to the screenreader\r\\@param politeness The politeness of the announcer element\n * @param {?} message\n * @param {?=} politeness\n * @return {?}\n */\nannounce(message: string, politeness: AriaLivePoliteness = 'polite'): void {\r\n    this._liveElement.textContent = '';\r\n\r\n    // TODO: ensure changing the politeness works on all environments we support.\r\n    this._liveElement.setAttribute('aria-live', politeness);\r\n\r\n    // This 100ms timeout is necessary for some browser + screen-reader combinations:\r\n    // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\r\n    // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a\r\n    //   second time without clearing and then using a non-zero delay.\r\n    // (using JAWS 17 at time of this writing).\r\n    setTimeout(() => this._liveElement.textContent = message, 100);\r\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\r\n    if (this._liveElement && this._liveElement.parentNode) {\r\n      this._liveElement.parentNode.removeChild(this._liveElement);\r\n    }\r\n  }\n/**\n * @return {?}\n */\nprivate _createLiveElement(): Element {\r\n    let /** @type {?} */ liveEl = document.createElement('div');\r\n\r\n    liveEl.classList.add('cdk-visually-hidden');\r\n    liveEl.setAttribute('aria-atomic', 'true');\r\n    liveEl.setAttribute('aria-live', 'polite');\r\n\r\n    document.body.appendChild(liveEl);\r\n\r\n    return liveEl;\r\n  }\r\n\r\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LIVE_ANNOUNCER_ELEMENT_TOKEN, ] }, ]},\n{type: Platform, },\n];\n}\n\nfunction LiveAnnouncer_tsickle_Closure_declarations() {\n/** @type {?} */\nLiveAnnouncer.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nLiveAnnouncer.ctorParameters;\n/** @type {?} */\nLiveAnnouncer.prototype._liveElement;\n}\n\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} liveElement\n * @param {?} platform\n * @return {?}\n */\nexport function LIVE_ANNOUNCER_PROVIDER_FACTORY(\r\n    parentDispatcher: LiveAnnouncer, liveElement: any, platform: Platform) {\r\n  return parentDispatcher || new LiveAnnouncer(liveElement, platform);\r\n}\n/**\n * \\@docs-private\n */\nexport const LIVE_ANNOUNCER_PROVIDER = {\r\n  // If there is already a LiveAnnouncer available, use that. Otherwise, provide a new one.\r\n  provide: LiveAnnouncer,\r\n  deps: [\r\n    [new Optional(), new SkipSelf(), LiveAnnouncer],\r\n    [new Optional(), new Inject(LIVE_ANNOUNCER_ELEMENT_TOKEN)],\r\n    Platform,\r\n  ],\r\n  useFactory: LIVE_ANNOUNCER_PROVIDER_FACTORY\r\n};\r\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {\r\n  Directive,\r\n  ElementRef,\r\n  Input,\r\n  NgZone,\r\n  OnDestroy,\r\n  AfterContentInit,\r\n  Injectable,\r\n} from '@angular/core';\r\nimport {coerceBooleanProperty} from '@angular/cdk/coercion';\r\nimport {Platform} from '@angular/cdk/platform';\r\nimport {first} from '@angular/cdk/rxjs';\r\nimport {InteractivityChecker} from './interactivity-checker';\n/**\n * Class that allows for trapping focus within a DOM element.\r\rNOTE: This class currently uses a very simple (naive) approach to focus trapping.\rIt assumes that the tab order is the same as DOM order, which is not necessarily true.\rThings like tabIndex > 0, flex `order`, and shadow roots can cause to two to misalign.\rThis will be replaced with a more intelligent solution before the library is considered stable.\n */\nexport class FocusTrap {\nprivate _startAnchor: HTMLElement | null;\nprivate _endAnchor: HTMLElement | null;\n/**\n * Whether the focus trap is active.\n * @return {?}\n */\nget enabled(): boolean { return this._enabled; }\n/**\n * @param {?} val\n * @return {?}\n */\nset enabled(val: boolean) {\r\n    this._enabled = val;\r\n\r\n    if (this._startAnchor && this._endAnchor) {\r\n      this._startAnchor.tabIndex = this._endAnchor.tabIndex = this._enabled ? 0 : -1;\r\n    }\r\n  }\nprivate _enabled: boolean = true;\n/**\n * @param {?} _element\n * @param {?} _platform\n * @param {?} _checker\n * @param {?} _ngZone\n * @param {?=} deferAnchors\n */\nconstructor(\nprivate _element: HTMLElement,\nprivate _platform: Platform,\nprivate _checker: InteractivityChecker,\nprivate _ngZone: NgZone,\r\n    deferAnchors = false) {\r\n\r\n    if (!deferAnchors) {\r\n      // this.attachAnchors();\r\n    }\r\n  }\n/**\n * Destroys the focus trap by cleaning up the anchors.\n * @return {?}\n */\ndestroy() {\r\n    if (this._startAnchor && this._startAnchor.parentNode) {\r\n      this._startAnchor.parentNode.removeChild(this._startAnchor);\r\n    }\r\n\r\n    if (this._endAnchor && this._endAnchor.parentNode) {\r\n      this._endAnchor.parentNode.removeChild(this._endAnchor);\r\n    }\r\n\r\n    this._startAnchor = this._endAnchor = null;\r\n  }\n/**\n * Inserts the anchors into the DOM. This is usually done automatically\rin the constructor, but can be deferred for cases like directives with `*ngIf`.\n * @return {?}\n */\nattachAnchors(): void {\r\n    // If we're not on the browser, there can be no focus to trap.\r\n    if (!this._platform.isBrowser) {\r\n      return;\r\n    }\r\n\r\n    if (!this._startAnchor) {\r\n      this._startAnchor = this._createAnchor();\r\n    }\r\n\r\n    if (!this._endAnchor) {\r\n      this._endAnchor = this._createAnchor();\r\n    }\r\n\r\n    this._ngZone.runOutsideAngular(() => { /** @type {?} */((\r\n      this._startAnchor)).addEventListener('focus', () => {\r\n        this.focusLastTabbableElement();\r\n      }); /** @type {?} */((\r\n\r\n      this._endAnchor)).addEventListener('focus', () => {\r\n        this.focusFirstTabbableElement();\r\n      });\r\n\r\n      if (this._element.parentNode) {\r\n        this._element.parentNode.insertBefore( /** @type {?} */((this._startAnchor)), this._element);\r\n        this._element.parentNode.insertBefore( /** @type {?} */((this._endAnchor)), this._element.nextSibling);\r\n      }\r\n    });\r\n  }\n/**\n * Waits for the zone to stabilize, then either focuses the first element that the\ruser specified, or the first tabbable element.\r\\@returns Returns a promise that resolves with a boolean, depending\ron whether focus was moved successfuly.\n * @return {?}\n */\nfocusInitialElementWhenReady(): Promise<boolean> {\r\n    return new Promise<boolean>(resolve => {\r\n      this._executeOnStable(() => resolve(this.focusInitialElement()));\r\n    });\r\n  }\n/**\n * Waits for the zone to stabilize, then focuses\rthe first tabbable element within the focus trap region.\r\\@returns Returns a promise that resolves with a boolean, depending\ron whether focus was moved successfuly.\n * @return {?}\n */\nfocusFirstTabbableElementWhenReady(): Promise<boolean> {\r\n    return new Promise<boolean>(resolve => {\r\n      this._executeOnStable(() => resolve(this.focusFirstTabbableElement()));\r\n    });\r\n  }\n/**\n * Waits for the zone to stabilize, then focuses\rthe last tabbable element within the focus trap region.\r\\@returns Returns a promise that resolves with a boolean, depending\ron whether focus was moved successfuly.\n * @return {?}\n */\nfocusLastTabbableElementWhenReady(): Promise<boolean> {\r\n    return new Promise<boolean>(resolve => {\r\n      this._executeOnStable(() => resolve(this.focusLastTabbableElement()));\r\n    });\r\n  }\n/**\n * Get the specified boundary element of the trapped region.\r\\@param bound The boundary to get (start or end of trapped region).\r\\@returns The boundary element.\n * @param {?} bound\n * @return {?}\n */\nprivate _getRegionBoundary(bound: 'start' | 'end'): HTMLElement | null {\r\n    // Contains the deprecated version of selector, for temporary backwards comparability.\r\n    let /** @type {?} */ markers = /** @type {?} */(( this._element.querySelectorAll(`[cdk-focus-region-${bound}], ` +\r\n                                                 `[cdk-focus-${bound}]`) as NodeListOf<HTMLElement>));\r\n\r\n    for (let /** @type {?} */ i = 0; i < markers.length; i++) {\r\n      if (markers[i].hasAttribute(`cdk-focus-${bound}`)) {\r\n        console.warn(`Found use of deprecated attribute 'cdk-focus-${bound}',` +\r\n                     ` use 'cdk-focus-region-${bound}' instead.`, markers[i]);\r\n      }\r\n    }\r\n\r\n    if (bound == 'start') {\r\n      return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);\r\n    }\r\n    return markers.length ?\r\n        markers[markers.length - 1] : this._getLastTabbableElement(this._element);\r\n  }\n/**\n * Focuses the element that should be focused when the focus trap is initialized.\r\\@returns Returns whether focus was moved successfuly.\n * @return {?}\n */\nfocusInitialElement(): boolean {\r\n    const /** @type {?} */ redirectToElement = /** @type {?} */(( this._element.querySelector('[cdk-focus-initial]') as HTMLElement));\r\n\r\n    if (redirectToElement) {\r\n      redirectToElement.focus();\r\n      return true;\r\n    }\r\n\r\n    return this.focusFirstTabbableElement();\r\n  }\n/**\n * Focuses the first tabbable element within the focus trap region.\r\\@returns Returns whether focus was moved successfuly.\n * @return {?}\n */\nfocusFirstTabbableElement(): boolean {\r\n    const /** @type {?} */ redirectToElement = this._getRegionBoundary('start');\r\n\r\n    if (redirectToElement) {\r\n      redirectToElement.focus();\r\n    }\r\n\r\n    return !!redirectToElement;\r\n  }\n/**\n * Focuses the last tabbable element within the focus trap region.\r\\@returns Returns whether focus was moved successfuly.\n * @return {?}\n */\nfocusLastTabbableElement(): boolean {\r\n    const /** @type {?} */ redirectToElement = this._getRegionBoundary('end');\r\n\r\n    if (redirectToElement) {\r\n      redirectToElement.focus();\r\n    }\r\n\r\n    return !!redirectToElement;\r\n  }\n/**\n * Get the first tabbable element from a DOM subtree (inclusive).\n * @param {?} root\n * @return {?}\n */\nprivate _getFirstTabbableElement(root: HTMLElement): HTMLElement | null {\r\n    if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\r\n      return root;\r\n    }\r\n\r\n    // Iterate in DOM order. Note that IE doesn't have `children` for SVG so we fall\r\n    // back to `childNodes` which includes text nodes, comments etc.\r\n    let /** @type {?} */ children = root.children || root.childNodes;\r\n\r\n    for (let /** @type {?} */ i = 0; i < children.length; i++) {\r\n      let /** @type {?} */ tabbableChild = children[i].nodeType === Node.ELEMENT_NODE ?\r\n        this._getFirstTabbableElement( /** @type {?} */((children[i] as HTMLElement))) :\r\n        null;\r\n\r\n      if (tabbableChild) {\r\n        return tabbableChild;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\n/**\n * Get the last tabbable element from a DOM subtree (inclusive).\n * @param {?} root\n * @return {?}\n */\nprivate _getLastTabbableElement(root: HTMLElement): HTMLElement | null {\r\n    if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\r\n      return root;\r\n    }\r\n\r\n    // Iterate in reverse DOM order.\r\n    let /** @type {?} */ children = root.children || root.childNodes;\r\n\r\n    for (let /** @type {?} */ i = children.length - 1; i >= 0; i--) {\r\n      let /** @type {?} */ tabbableChild = children[i].nodeType === Node.ELEMENT_NODE ?\r\n        this._getLastTabbableElement( /** @type {?} */((children[i] as HTMLElement))) :\r\n        null;\r\n\r\n      if (tabbableChild) {\r\n        return tabbableChild;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\n/**\n * Creates an anchor element.\n * @return {?}\n */\nprivate _createAnchor(): HTMLElement {\r\n    let /** @type {?} */ anchor = document.createElement('div');\r\n    anchor.tabIndex = this._enabled ? 0 : -1;\r\n    anchor.classList.add('cdk-visually-hidden');\r\n    anchor.classList.add('cdk-focus-trap-anchor');\r\n    return anchor;\r\n  }\n/**\n * Executes a function when the zone is stable.\n * @param {?} fn\n * @return {?}\n */\nprivate _executeOnStable(fn: () => any): void {\r\n    if (this._ngZone.isStable) {\r\n      fn();\r\n    } else {\r\n      first.call(this._ngZone.onStable).subscribe(fn);\r\n    }\r\n  }\r\n}\n\nfunction FocusTrap_tsickle_Closure_declarations() {\n/** @type {?} */\nFocusTrap.prototype._startAnchor;\n/** @type {?} */\nFocusTrap.prototype._endAnchor;\n/** @type {?} */\nFocusTrap.prototype._enabled;\n/** @type {?} */\nFocusTrap.prototype._element;\n/** @type {?} */\nFocusTrap.prototype._platform;\n/** @type {?} */\nFocusTrap.prototype._checker;\n/** @type {?} */\nFocusTrap.prototype._ngZone;\n}\n\n/**\n * Factory that allows easy instantiation of focus traps.\n */\nexport class FocusTrapFactory {\n/**\n * @param {?} _checker\n * @param {?} _platform\n * @param {?} _ngZone\n */\nconstructor(\nprivate _checker: InteractivityChecker,\nprivate _platform: Platform,\nprivate _ngZone: NgZone) { }\n/**\n * @param {?} element\n * @param {?=} deferAnchors\n * @return {?}\n */\ncreate(element: HTMLElement, deferAnchors = false): FocusTrap {\r\n    return new FocusTrap(element, this._platform, this._checker, this._ngZone, deferAnchors);\r\n  }\r\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: InteractivityChecker, },\n{type: Platform, },\n{type: NgZone, },\n];\n}\n\nfunction FocusTrapFactory_tsickle_Closure_declarations() {\n/** @type {?} */\nFocusTrapFactory.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nFocusTrapFactory.ctorParameters;\n/** @type {?} */\nFocusTrapFactory.prototype._checker;\n/** @type {?} */\nFocusTrapFactory.prototype._platform;\n/** @type {?} */\nFocusTrapFactory.prototype._ngZone;\n}\n\n/**\n * Directive for trapping focus within a region.\r\\@deprecated\n */\nexport class FocusTrapDeprecatedDirective implements OnDestroy, AfterContentInit {\r\n  focusTrap: FocusTrap;\n/**\n * Whether the focus trap is active.\n * @return {?}\n */\nget disabled(): boolean { return !this.focusTrap.enabled; }\n/**\n * @param {?} val\n * @return {?}\n */\nset disabled(val: boolean) {\r\n    this.focusTrap.enabled = !coerceBooleanProperty(val);\r\n  }\n/**\n * @param {?} _elementRef\n * @param {?} _focusTrapFactory\n */\nconstructor(private _elementRef: ElementRef,\nprivate _focusTrapFactory: FocusTrapFactory) {\r\n    this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\r\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\r\n    this.focusTrap.destroy();\r\n  }\n/**\n * @return {?}\n */\nngAfterContentInit() {\r\n    this.focusTrap.attachAnchors();\r\n  }\r\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{\r\n  selector: 'cdk-focus-trap',\r\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ElementRef, },\n{type: FocusTrapFactory, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'disabled': [{ type: Input },],\n};\n}\n\nfunction FocusTrapDeprecatedDirective_tsickle_Closure_declarations() {\n/** @type {?} */\nFocusTrapDeprecatedDirective.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nFocusTrapDeprecatedDirective.ctorParameters;\n/** @type {?} */\nFocusTrapDeprecatedDirective.propDecorators;\n/** @type {?} */\nFocusTrapDeprecatedDirective.prototype.focusTrap;\n/** @type {?} */\nFocusTrapDeprecatedDirective.prototype._elementRef;\n/** @type {?} */\nFocusTrapDeprecatedDirective.prototype._focusTrapFactory;\n}\n\n/**\n * Directive for trapping focus within a region.\n */\nexport class FocusTrapDirective implements OnDestroy, AfterContentInit {\r\n  focusTrap: FocusTrap;\n/**\n * Whether the focus trap is active.\n * @return {?}\n */\nget enabled(): boolean { return this.focusTrap.enabled; }\n/**\n * @param {?} value\n * @return {?}\n */\nset enabled(value: boolean) { this.focusTrap.enabled = coerceBooleanProperty(value); }\n/**\n * @param {?} _elementRef\n * @param {?} _focusTrapFactory\n */\nconstructor(private _elementRef: ElementRef,\nprivate _focusTrapFactory: FocusTrapFactory) {\r\n    this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\r\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\r\n    this.focusTrap.destroy();\r\n  }\n/**\n * @return {?}\n */\nngAfterContentInit() {\r\n    this.focusTrap.attachAnchors();\r\n  }\r\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{\r\n  selector: '[cdkTrapFocus]',\r\n  exportAs: 'cdkTrapFocus',\r\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ElementRef, },\n{type: FocusTrapFactory, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'enabled': [{ type: Input, args: ['cdkTrapFocus', ] },],\n};\n}\n\nfunction FocusTrapDirective_tsickle_Closure_declarations() {\n/** @type {?} */\nFocusTrapDirective.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nFocusTrapDirective.ctorParameters;\n/** @type {?} */\nFocusTrapDirective.propDecorators;\n/** @type {?} */\nFocusTrapDirective.prototype.focusTrap;\n/** @type {?} */\nFocusTrapDirective.prototype._elementRef;\n/** @type {?} */\nFocusTrapDirective.prototype._focusTrapFactory;\n}\n\r\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {Injectable} from '@angular/core';\r\nimport {Platform} from '@angular/cdk/platform';\n/**\n * Utility for checking the interactivity of an element, such as whether is is focusable or\rtabbable.\n */\nexport class InteractivityChecker {\n/**\n * @param {?} _platform\n */\nconstructor(private _platform: Platform) {}\n/**\n * Gets whether an element is disabled.\r\r\\@param element Element to be checked.\r\\@returns Whether the element is disabled.\n * @param {?} element\n * @return {?}\n */\nisDisabled(element: HTMLElement): boolean {\r\n    // This does not capture some cases, such as a non-form control with a disabled attribute or\r\n    // a form control inside of a disabled form, but should capture the most common cases.\r\n    return element.hasAttribute('disabled');\r\n  }\n/**\n * Gets whether an element is visible for the purposes of interactivity.\r\rThis will capture states like `display: none` and `visibility: hidden`, but not things like\rbeing clipped by an `overflow: hidden` parent or being outside the viewport.\r\r\\@returns Whether the element is visible.\n * @param {?} element\n * @return {?}\n */\nisVisible(element: HTMLElement): boolean {\r\n    return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';\r\n  }\n/**\n * Gets whether an element can be reached via Tab key.\rAssumes that the element has already been checked with isFocusable.\r\r\\@param element Element to be checked.\r\\@returns Whether the element is tabbable.\n * @param {?} element\n * @return {?}\n */\nisTabbable(element: HTMLElement): boolean {\r\n    // Nothing is tabbable on the the server ðŸ˜Ž\r\n    if (!this._platform.isBrowser) {\r\n      return false;\r\n    }\r\n\r\n    let /** @type {?} */ frameElement = /** @type {?} */(( getWindow(element).frameElement as HTMLElement));\r\n\r\n    if (frameElement) {\r\n\r\n      let /** @type {?} */ frameType = frameElement && frameElement.nodeName.toLowerCase();\r\n\r\n      // Frame elements inherit their tabindex onto all child elements.\r\n      if (getTabIndexValue(frameElement) === -1) {\r\n        return false;\r\n      }\r\n\r\n      // Webkit and Blink consider anything inside of an <object> element as non-tabbable.\r\n      if ((this._platform.BLINK || this._platform.WEBKIT) && frameType === 'object') {\r\n        return false;\r\n      }\r\n\r\n      // Webkit and Blink disable tabbing to an element inside of an invisible frame.\r\n      if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(frameElement)) {\r\n        return false;\r\n      }\r\n\r\n    }\r\n\r\n    let /** @type {?} */ nodeName = element.nodeName.toLowerCase();\r\n    let /** @type {?} */ tabIndexValue = getTabIndexValue(element);\r\n\r\n    if (element.hasAttribute('contenteditable')) {\r\n      return tabIndexValue !== -1;\r\n    }\r\n\r\n    if (nodeName === 'iframe') {\r\n      // The frames may be tabbable depending on content, but it's not possibly to reliably\r\n      // investigate the content of the frames.\r\n      return false;\r\n    }\r\n\r\n    if (nodeName === 'audio') {\r\n      if (!element.hasAttribute('controls')) {\r\n        // By default an <audio> element without the controls enabled is not tabbable.\r\n        return false;\r\n      } else if (this._platform.BLINK) {\r\n        // In Blink <audio controls> elements are always tabbable.\r\n        return true;\r\n      }\r\n    }\r\n\r\n    if (nodeName === 'video') {\r\n      if (!element.hasAttribute('controls') && this._platform.TRIDENT) {\r\n        // In Trident a <video> element without the controls enabled is not tabbable.\r\n        return false;\r\n      } else if (this._platform.BLINK || this._platform.FIREFOX) {\r\n        // In Chrome and Firefox <video controls> elements are always tabbable.\r\n        return true;\r\n      }\r\n    }\r\n\r\n    if (nodeName === 'object' && (this._platform.BLINK || this._platform.WEBKIT)) {\r\n      // In all Blink and WebKit based browsers <object> elements are never tabbable.\r\n      return false;\r\n    }\r\n\r\n    // In iOS the browser only considers some specific elements as tabbable.\r\n    if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {\r\n      return false;\r\n    }\r\n\r\n    return element.tabIndex >= 0;\r\n  }\n/**\n * Gets whether an element can be focused by the user.\r\r\\@param element Element to be checked.\r\\@returns Whether the element is focusable.\n * @param {?} element\n * @return {?}\n */\nisFocusable(element: HTMLElement): boolean {\r\n    // Perform checks in order of left to most expensive.\r\n    // Again, naive approach that does not capture many edge cases and browser quirks.\r\n    return isPotentiallyFocusable(element) && !this.isDisabled(element) && this.isVisible(element);\r\n  }\r\n\r\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: Platform, },\n];\n}\n\nfunction InteractivityChecker_tsickle_Closure_declarations() {\n/** @type {?} */\nInteractivityChecker.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nInteractivityChecker.ctorParameters;\n/** @type {?} */\nInteractivityChecker.prototype._platform;\n}\n\n/**\n * Checks whether the specified element has any geometry / rectangles.\n * @param {?} element\n * @return {?}\n */\nfunction hasGeometry(element: HTMLElement): boolean {\r\n  // Use logic from jQuery to check for an invisible element.\r\n  // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12\r\n  return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);\r\n}\n/**\n * Gets whether an element's\n * @param {?} element\n * @return {?}\n */\nfunction isNativeFormElement(element: Node) {\r\n  let /** @type {?} */ nodeName = element.nodeName.toLowerCase();\r\n  return nodeName === 'input' ||\r\n      nodeName === 'select' ||\r\n      nodeName === 'button' ||\r\n      nodeName === 'textarea';\r\n}\n/**\n * Gets whether an element is an <input type=\"hidden\">.\n * @param {?} element\n * @return {?}\n */\nfunction isHiddenInput(element: HTMLElement): boolean {\r\n  return isInputElement(element) && element.type == 'hidden';\r\n}\n/**\n * Gets whether an element is an anchor that has an href attribute.\n * @param {?} element\n * @return {?}\n */\nfunction isAnchorWithHref(element: HTMLElement): boolean {\r\n  return isAnchorElement(element) && element.hasAttribute('href');\r\n}\n/**\n * Gets whether an element is an input element.\n * @param {?} element\n * @return {?}\n */\nfunction isInputElement(element: HTMLElement): element is HTMLInputElement {\r\n  return element.nodeName.toLowerCase() == 'input';\r\n}\n/**\n * Gets whether an element is an anchor element.\n * @param {?} element\n * @return {?}\n */\nfunction isAnchorElement(element: HTMLElement): element is HTMLAnchorElement {\r\n  return element.nodeName.toLowerCase() == 'a';\r\n}\n/**\n * Gets whether an element has a valid tabindex.\n * @param {?} element\n * @return {?}\n */\nfunction hasValidTabIndex(element: HTMLElement): boolean {\r\n  if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {\r\n    return false;\r\n  }\r\n\r\n  let /** @type {?} */ tabIndex = element.getAttribute('tabindex');\r\n\r\n  // IE11 parses tabindex=\"\" as the value \"-32768\"\r\n  if (tabIndex == '-32768') {\r\n    return false;\r\n  }\r\n\r\n  return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));\r\n}\n/**\n * Returns the parsed tabindex from the element attributes instead of returning the\revaluated tabindex from the browsers defaults.\n * @param {?} element\n * @return {?}\n */\nfunction getTabIndexValue(element: HTMLElement): number | null {\r\n  if (!hasValidTabIndex(element)) {\r\n    return null;\r\n  }\r\n\r\n  // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\r\n  const /** @type {?} */ tabIndex = parseInt(element.getAttribute('tabindex') || '', 10);\r\n\r\n  return isNaN(tabIndex) ? -1 : tabIndex;\r\n}\n/**\n * Checks whether the specified element is potentially tabbable on iOS\n * @param {?} element\n * @return {?}\n */\nfunction isPotentiallyTabbableIOS(element: HTMLElement): boolean {\r\n  let /** @type {?} */ nodeName = element.nodeName.toLowerCase();\r\n  let /** @type {?} */ inputType = nodeName === 'input' && ( /** @type {?} */((element as HTMLInputElement))).type;\r\n\r\n  return inputType === 'text'\r\n      || inputType === 'password'\r\n      || nodeName === 'select'\r\n      || nodeName === 'textarea';\r\n}\n/**\n * Gets whether an element is potentially focusable without taking current visible/disabled state\rinto account.\n * @param {?} element\n * @return {?}\n */\nfunction isPotentiallyFocusable(element: HTMLElement): boolean {\r\n  // Inputs are potentially focusable *unless* they're type=\"hidden\".\r\n  if (isHiddenInput(element)) {\r\n    return false;\r\n  }\r\n\r\n  return isNativeFormElement(element) ||\r\n      isAnchorWithHref(element) ||\r\n      element.hasAttribute('contenteditable') ||\r\n      hasValidTabIndex(element);\r\n}\n/**\n * Gets the parent window of a DOM node with regards of being inside of an iframe.\n * @param {?} node\n * @return {?}\n */\nfunction getWindow(node: HTMLElement): Window {\r\n  return node.ownerDocument.defaultView || window;\r\n}\r\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"],"names":[],"mappings":"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"}