{"version":3,"file":"cdk-overlay.umd.min.js","sources":["../../node_modules/tslib/tslib.es6.js","../../src/cdk/overlay/position/scroll-clip.ts","../../src/cdk/overlay/position/connected-position-strategy.ts","../../src/cdk/overlay/scroll/close-scroll-strategy.ts","../../src/cdk/overlay/overlay-directives.ts","../../src/cdk/overlay/scroll/noop-scroll-strategy.ts","../../src/cdk/overlay/overlay-state.ts","../../src/cdk/overlay/overlay-ref.ts","../../src/cdk/overlay/position/connected-position.ts","../../src/cdk/overlay/position/global-position-strategy.ts","../../src/cdk/overlay/position/overlay-position-builder.ts","../../src/cdk/overlay/overlay-container.ts","../../src/cdk/overlay/scroll/scroll-strategy.ts","../../src/cdk/overlay/scroll/block-scroll-strategy.ts","../../src/cdk/overlay/scroll/reposition-scroll-strategy.ts","../../src/cdk/overlay/scroll/scroll-strategy-options.ts","../../src/cdk/overlay/overlay.ts","../../src/cdk/overlay/public_api.ts","../../src/cdk/overlay/fullscreen-overlay-container.ts","../../src/cdk/overlay/index.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}","\n/**\n * Gets whether an element is scrolled outside of view by any of its parent scrolling containers.\r\\@param element Dimensions of the element (from getBoundingClientRect)\r\\@param scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\r\\@returns Whether the element is scrolled out of view\r\\@docs-private\n * @param {?} element\n * @param {?} scrollContainers\n * @return {?}\n */\nexport function isElementScrolledOutsideView(element: ClientRect, scrollContainers: ClientRect[]) {\r\n  return scrollContainers.some(containerBounds => {\r\n    const /** @type {?} */ outsideAbove = element.bottom < containerBounds.top;\r\n    const /** @type {?} */ outsideBelow = element.top > containerBounds.bottom;\r\n    const /** @type {?} */ outsideLeft = element.right < containerBounds.left;\r\n    const /** @type {?} */ outsideRight = element.left > containerBounds.right;\r\n\r\n    return outsideAbove || outsideBelow || outsideLeft || outsideRight;\r\n  });\r\n}\n/**\n * Gets whether an element is clipped by any of its scrolling containers.\r\\@param element Dimensions of the element (from getBoundingClientRect)\r\\@param scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\r\\@returns Whether the element is clipped\r\\@docs-private\n * @param {?} element\n * @param {?} scrollContainers\n * @return {?}\n */\nexport function isElementClippedByScrolling(element: ClientRect, scrollContainers: ClientRect[]) {\r\n  return scrollContainers.some(scrollContainerRect => {\r\n    const /** @type {?} */ clippedAbove = element.top < scrollContainerRect.top;\r\n    const /** @type {?} */ clippedBelow = element.bottom > scrollContainerRect.bottom;\r\n    const /** @type {?} */ clippedLeft = element.left < scrollContainerRect.left;\r\n    const /** @type {?} */ clippedRight = element.right > scrollContainerRect.right;\r\n\r\n    return clippedAbove || clippedBelow || clippedLeft || clippedRight;\r\n  });\r\n}\r\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {PositionStrategy} from './position-strategy';\r\nimport {ElementRef} from '@angular/core';\r\nimport {ViewportRuler} from '@angular/cdk/scrolling';\r\nimport {\r\n  ConnectionPositionPair,\r\n  OriginConnectionPosition,\r\n  OverlayConnectionPosition,\r\n  ConnectedOverlayPositionChange,\r\n  ScrollingVisibility,\r\n} from './connected-position';\r\nimport {Subject} from 'rxjs/Subject';\r\nimport {Observable} from 'rxjs/Observable';\r\nimport {Scrollable} from '@angular/cdk/scrolling';\r\nimport {isElementScrolledOutsideView, isElementClippedByScrolling} from './scroll-clip';\r\nimport {OverlayRef} from '../overlay-ref';\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\rimplicit position relative some origin element. The relative position is defined in terms of\ra point on the origin element that is connected to a point on the overlay element. For example,\ra basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\rof the overlay.\n */\nexport class ConnectedPositionStrategy implements PositionStrategy {\n/**\n * The overlay to which this strategy is attached.\n */\nprivate _overlayRef: OverlayRef;\nprivate _dir = 'ltr';\n/**\n * The offset in pixels for the overlay connection point on the x-axis\n */\nprivate _offsetX: number = 0;\n/**\n * The offset in pixels for the overlay connection point on the y-axis\n */\nprivate _offsetY: number = 0;\n/**\n * The Scrollable containers used to check scrollable view properties on position change.\n */\nprivate scrollables: Scrollable[] = [];\n/**\n * Whether the we're dealing with an RTL context\n * @return {?}\n */\nget _isRtl() {\r\n    return this._dir === 'rtl';\r\n  }\n/**\n * Ordered list of preferred positions, from most to least desirable.\n */\n_preferredPositions: ConnectionPositionPair[] = [];\n/**\n * The origin element against which the overlay will be positioned.\n */\nprivate _origin: HTMLElement;\n/**\n * The overlay pane element.\n */\nprivate _pane: HTMLElement;\n/**\n * The last position to have been calculated as the best fit position.\n */\nprivate _lastConnectedPosition: ConnectionPositionPair;\r\n\r\n  _onPositionChange:\r\n      Subject<ConnectedOverlayPositionChange> = new Subject<ConnectedOverlayPositionChange>();\n/**\n * Emits an event when the connection point changes.\n * @return {?}\n */\nget onPositionChange(): Observable<ConnectedOverlayPositionChange> {\r\n    return this._onPositionChange.asObservable();\r\n  }\n/**\n * @param {?} originPos\n * @param {?} overlayPos\n * @param {?} _connectedTo\n * @param {?} _viewportRuler\n */\nconstructor(\r\n      originPos: OriginConnectionPosition,\r\n      overlayPos: OverlayConnectionPosition,\nprivate _connectedTo: ElementRef,\nprivate _viewportRuler: ViewportRuler) {\r\n    this._origin = this._connectedTo.nativeElement;\r\n    this.withFallbackPosition(originPos, overlayPos);\r\n  }\n/**\n * Ordered list of preferred positions, from most to least desirable.\n * @return {?}\n */\nget positions() {\r\n    return this._preferredPositions;\r\n  }\n/**\n * @param {?} overlayRef\n * @return {?}\n */\nattach(overlayRef: OverlayRef): void {\r\n    this._overlayRef = overlayRef;\r\n    this._pane = overlayRef.overlayElement;\r\n  }\n/**\n * Performs any cleanup after the element is destroyed.\n * @return {?}\n */\ndispose() { }\n/**\n * Updates the position of the overlay element, using whichever preferred position relative\rto the origin fits on-screen.\r\\@docs-private\r\r\\@returns Resolves when the styles have been applied.\n * @return {?}\n */\napply(): void {\r\n    // We need the bounding rects for the origin and the overlay to determine how to position\r\n    // the overlay relative to the origin.\r\n    const /** @type {?} */ element = this._pane;\r\n    const /** @type {?} */ originRect = this._origin.getBoundingClientRect();\r\n    const /** @type {?} */ overlayRect = element.getBoundingClientRect();\r\n\r\n    // We use the viewport rect to determine whether a position would go off-screen.\r\n    const /** @type {?} */ viewportRect = this._viewportRuler.getViewportRect();\r\n\r\n    // Fallback point if none of the fallbacks fit into the viewport.\r\n    let /** @type {?} */ fallbackPoint: OverlayPoint | undefined;\r\n    let /** @type {?} */ fallbackPosition: ConnectionPositionPair | undefined;\r\n\r\n    // We want to place the overlay in the first of the preferred positions such that the\r\n    // overlay fits on-screen.\r\n    for (let /** @type {?} */ pos of this._preferredPositions) {\r\n      // Get the (x, y) point of connection on the origin, and then use that to get the\r\n      // (top, left) coordinate for the overlay at `pos`.\r\n      let /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, pos);\r\n      let /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportRect, pos);\r\n\r\n      // If the overlay in the calculated position fits on-screen, put it there and we're done.\r\n      if (overlayPoint.fitsInViewport) {\r\n        this._setElementPosition(element, overlayRect, overlayPoint, pos);\r\n\r\n        // Save the last connected position in case the position needs to be re-calculated.\r\n        this._lastConnectedPosition = pos;\r\n\r\n        return;\r\n      } else if (!fallbackPoint || fallbackPoint.visibleArea < overlayPoint.visibleArea) {\r\n        fallbackPoint = overlayPoint;\r\n        fallbackPosition = pos;\r\n      }\r\n    }\r\n\r\n    // If none of the preferred positions were in the viewport, take the one\r\n    // with the largest visible area.\r\n    this._setElementPosition(element, overlayRect, /** @type {?} */(( fallbackPoint)), /** @type {?} */(( fallbackPosition)));\r\n  }\n/**\n * This re-aligns the overlay element with the trigger in its last calculated position,\reven if a position higher in the \"preferred positions\" list would now fit. This\rallows one to re-align the panel without changing the orientation of the panel.\n * @return {?}\n */\nrecalculateLastPosition(): void {\r\n    const /** @type {?} */ originRect = this._origin.getBoundingClientRect();\r\n    const /** @type {?} */ overlayRect = this._pane.getBoundingClientRect();\r\n    const /** @type {?} */ viewportRect = this._viewportRuler.getViewportRect();\r\n    const /** @type {?} */ lastPosition = this._lastConnectedPosition || this._preferredPositions[0];\r\n\r\n    let /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, lastPosition);\r\n    let /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportRect, lastPosition);\r\n    this._setElementPosition(this._pane, overlayRect, overlayPoint, lastPosition);\r\n  }\n/**\n * Sets the list of Scrollable containers that host the origin element so that\ron reposition we can evaluate if it or the overlay has been clipped or outside view. Every\rScrollable must be an ancestor element of the strategy's origin element.\n * @param {?} scrollables\n * @return {?}\n */\nwithScrollableContainers(scrollables: Scrollable[]) {\r\n    this.scrollables = scrollables;\r\n  }\n/**\n * Adds a new preferred fallback position.\r\\@param originPos\r\\@param overlayPos\n * @param {?} originPos\n * @param {?} overlayPos\n * @return {?}\n */\nwithFallbackPosition(\r\n      originPos: OriginConnectionPosition,\r\n      overlayPos: OverlayConnectionPosition): this {\r\n    this._preferredPositions.push(new ConnectionPositionPair(originPos, overlayPos));\r\n    return this;\r\n  }\n/**\n * Sets the layout direction so the overlay's position can be adjusted to match.\r\\@param dir New layout direction.\n * @param {?} dir\n * @return {?}\n */\nwithDirection(dir: 'ltr' | 'rtl'): this {\r\n    this._dir = dir;\r\n    return this;\r\n  }\n/**\n * Sets an offset for the overlay's connection point on the x-axis\r\\@param offset New offset in the X axis.\n * @param {?} offset\n * @return {?}\n */\nwithOffsetX(offset: number): this {\r\n    this._offsetX = offset;\r\n    return this;\r\n  }\n/**\n * Sets an offset for the overlay's connection point on the y-axis\r\\@param  offset New offset in the Y axis.\n * @param {?} offset\n * @return {?}\n */\nwithOffsetY(offset: number): this {\r\n    this._offsetY = offset;\r\n    return this;\r\n  }\n/**\n * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\r\\@param rect\n * @param {?} rect\n * @return {?}\n */\nprivate _getStartX(rect: ClientRect): number {\r\n    return this._isRtl ? rect.right : rect.left;\r\n  }\n/**\n * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\r\\@param rect\n * @param {?} rect\n * @return {?}\n */\nprivate _getEndX(rect: ClientRect): number {\r\n    return this._isRtl ? rect.left : rect.right;\r\n  }\n/**\n * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\r\\@param originRect\r\\@param pos\n * @param {?} originRect\n * @param {?} pos\n * @return {?}\n */\nprivate _getOriginConnectionPoint(originRect: ClientRect, pos: ConnectionPositionPair): Point {\r\n    const /** @type {?} */ originStartX = this._getStartX(originRect);\r\n    const /** @type {?} */ originEndX = this._getEndX(originRect);\r\n\r\n    let /** @type {?} */ x: number;\r\n    if (pos.originX == 'center') {\r\n      x = originStartX + (originRect.width / 2);\r\n    } else {\r\n      x = pos.originX == 'start' ? originStartX : originEndX;\r\n    }\r\n\r\n    let /** @type {?} */ y: number;\r\n    if (pos.originY == 'center') {\r\n      y = originRect.top + (originRect.height / 2);\r\n    } else {\r\n      y = pos.originY == 'top' ? originRect.top : originRect.bottom;\r\n    }\r\n\r\n    return {x, y};\r\n  }\n/**\n * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\rorigin point to which the overlay should be connected, as well as how much of the element\rwould be inside the viewport at that position.\n * @param {?} originPoint\n * @param {?} overlayRect\n * @param {?} viewportRect\n * @param {?} pos\n * @return {?}\n */\nprivate _getOverlayPoint(\r\n      originPoint: Point,\r\n      overlayRect: ClientRect,\r\n      viewportRect: ClientRect,\r\n      pos: ConnectionPositionPair): OverlayPoint {\r\n    // Calculate the (overlayStartX, overlayStartY), the start of the potential overlay position\r\n    // relative to the origin point.\r\n    let /** @type {?} */ overlayStartX: number;\r\n    if (pos.overlayX == 'center') {\r\n      overlayStartX = -overlayRect.width / 2;\r\n    } else if (pos.overlayX === 'start') {\r\n      overlayStartX = this._isRtl ? -overlayRect.width : 0;\r\n    } else {\r\n      overlayStartX = this._isRtl ? 0 : -overlayRect.width;\r\n    }\r\n\r\n    let /** @type {?} */ overlayStartY: number;\r\n    if (pos.overlayY == 'center') {\r\n      overlayStartY = -overlayRect.height / 2;\r\n    } else {\r\n      overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\r\n    }\r\n\r\n    // The (x, y) coordinates of the overlay.\r\n    let /** @type {?} */ x = originPoint.x + overlayStartX + this._offsetX;\r\n    let /** @type {?} */ y = originPoint.y + overlayStartY + this._offsetY;\r\n\r\n    // How much the overlay would overflow at this position, on each side.\r\n    let /** @type {?} */ leftOverflow = 0 - x;\r\n    let /** @type {?} */ rightOverflow = (x + overlayRect.width) - viewportRect.width;\r\n    let /** @type {?} */ topOverflow = 0 - y;\r\n    let /** @type {?} */ bottomOverflow = (y + overlayRect.height) - viewportRect.height;\r\n\r\n    // Visible parts of the element on each axis.\r\n    let /** @type {?} */ visibleWidth = this._subtractOverflows(overlayRect.width, leftOverflow, rightOverflow);\r\n    let /** @type {?} */ visibleHeight = this._subtractOverflows(overlayRect.height, topOverflow, bottomOverflow);\r\n\r\n    // The area of the element that's within the viewport.\r\n    let /** @type {?} */ visibleArea = visibleWidth * visibleHeight;\r\n    let /** @type {?} */ fitsInViewport = (overlayRect.width * overlayRect.height) === visibleArea;\r\n\r\n    return {x, y, fitsInViewport, visibleArea};\r\n  }\n/**\n * Gets the view properties of the trigger and overlay, including whether they are clipped\ror completely outside the view of any of the strategy's scrollables.\n * @param {?} overlay\n * @return {?}\n */\nprivate _getScrollVisibility(overlay: HTMLElement): ScrollingVisibility {\r\n    const /** @type {?} */ originBounds = this._origin.getBoundingClientRect();\r\n    const /** @type {?} */ overlayBounds = overlay.getBoundingClientRect();\r\n    const /** @type {?} */ scrollContainerBounds =\r\n        this.scrollables.map(s => s.getElementRef().nativeElement.getBoundingClientRect());\r\n\r\n    return {\r\n      isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),\r\n      isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),\r\n      isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),\r\n      isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds),\r\n    };\r\n  }\n/**\n * Physically positions the overlay element to the given coordinate.\n * @param {?} element\n * @param {?} overlayRect\n * @param {?} overlayPoint\n * @param {?} pos\n * @return {?}\n */\nprivate _setElementPosition(\r\n      element: HTMLElement,\r\n      overlayRect: ClientRect,\r\n      overlayPoint: Point,\r\n      pos: ConnectionPositionPair) {\r\n\r\n    // We want to set either `top` or `bottom` based on whether the overlay wants to appear above\r\n    // or below the origin and the direction in which the element will expand.\r\n    let /** @type {?} */ verticalStyleProperty = pos.overlayY === 'bottom' ? 'bottom' : 'top';\r\n\r\n    // When using `bottom`, we adjust the y position such that it is the distance\r\n    // from the bottom of the viewport rather than the top.\r\n    let /** @type {?} */ y = verticalStyleProperty === 'top' ?\r\n        overlayPoint.y :\r\n        document.documentElement.clientHeight - (overlayPoint.y + overlayRect.height);\r\n\r\n    // We want to set either `left` or `right` based on whether the overlay wants to appear \"before\"\r\n    // or \"after\" the origin, which determines the direction in which the element will expand.\r\n    // For the horizontal axis, the meaning of \"before\" and \"after\" change based on whether the\r\n    // page is in RTL or LTR.\r\n    let /** @type {?} */ horizontalStyleProperty: string;\r\n    if (this._dir === 'rtl') {\r\n      horizontalStyleProperty = pos.overlayX === 'end' ? 'left' : 'right';\r\n    } else {\r\n      horizontalStyleProperty = pos.overlayX === 'end' ? 'right' : 'left';\r\n    }\r\n\r\n    // When we're setting `right`, we adjust the x position such that it is the distance\r\n    // from the right edge of the viewport rather than the left edge.\r\n    let /** @type {?} */ x = horizontalStyleProperty === 'left' ?\r\n      overlayPoint.x :\r\n      document.documentElement.clientWidth - (overlayPoint.x + overlayRect.width);\r\n\r\n\r\n    // Reset any existing styles. This is necessary in case the preferred position has\r\n    // changed since the last `apply`.\r\n    ['top', 'bottom', 'left', 'right'].forEach(p => element.style[p] = null);\r\n\r\n    element.style[verticalStyleProperty] = `${y}px`;\r\n    element.style[horizontalStyleProperty] = `${x}px`;\r\n\r\n    // Notify that the position has been changed along with its change properties.\r\n    const /** @type {?} */ scrollableViewProperties = this._getScrollVisibility(element);\r\n    const /** @type {?} */ positionChange = new ConnectedOverlayPositionChange(pos, scrollableViewProperties);\r\n    this._onPositionChange.next(positionChange);\r\n  }\n/**\n * Subtracts the amount that an element is overflowing on an axis from it's length.\n * @param {?} length\n * @param {...?} overflows\n * @return {?}\n */\nprivate _subtractOverflows(length: number, ...overflows: number[]): number {\r\n    return overflows.reduce((currentValue: number, currentOverflow: number) => {\r\n      return currentValue - Math.max(currentOverflow, 0);\r\n    }, length);\r\n  }\r\n}\n\nfunction ConnectedPositionStrategy_tsickle_Closure_declarations() {\n/**\n * The overlay to which this strategy is attached.\n * @type {?}\n */\nConnectedPositionStrategy.prototype._overlayRef;\n/** @type {?} */\nConnectedPositionStrategy.prototype._dir;\n/**\n * The offset in pixels for the overlay connection point on the x-axis\n * @type {?}\n */\nConnectedPositionStrategy.prototype._offsetX;\n/**\n * The offset in pixels for the overlay connection point on the y-axis\n * @type {?}\n */\nConnectedPositionStrategy.prototype._offsetY;\n/**\n * The Scrollable containers used to check scrollable view properties on position change.\n * @type {?}\n */\nConnectedPositionStrategy.prototype.scrollables;\n/**\n * Ordered list of preferred positions, from most to least desirable.\n * @type {?}\n */\nConnectedPositionStrategy.prototype._preferredPositions;\n/**\n * The origin element against which the overlay will be positioned.\n * @type {?}\n */\nConnectedPositionStrategy.prototype._origin;\n/**\n * The overlay pane element.\n * @type {?}\n */\nConnectedPositionStrategy.prototype._pane;\n/**\n * The last position to have been calculated as the best fit position.\n * @type {?}\n */\nConnectedPositionStrategy.prototype._lastConnectedPosition;\n/** @type {?} */\nConnectedPositionStrategy.prototype._onPositionChange;\n/** @type {?} */\nConnectedPositionStrategy.prototype._connectedTo;\n/** @type {?} */\nConnectedPositionStrategy.prototype._viewportRuler;\n}\n\r\n\r\n/** A simple (x, y) coordinate. */\r\ninterface Point {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\n/**\r\n * Expands the simple (x, y) coordinate by adding info about whether the\r\n * element would fit inside the viewport at that position, as well as\r\n * how much of the element would be visible.\r\n */\r\ninterface OverlayPoint extends Point {\r\n  visibleArea: number;\r\n  fitsInViewport: boolean;\r\n}\r\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {ScrollStrategy, getMdScrollStrategyAlreadyAttachedError} from './scroll-strategy';\r\nimport {OverlayRef} from '../overlay-ref';\r\nimport {Subscription} from 'rxjs/Subscription';\r\nimport {ScrollDispatcher} from '@angular/cdk/scrolling';\n/**\n * Strategy that will close the overlay as soon as the user starts scrolling.\n */\nexport class CloseScrollStrategy implements ScrollStrategy {\nprivate _scrollSubscription: Subscription|null = null;\nprivate _overlayRef: OverlayRef;\n/**\n * @param {?} _scrollDispatcher\n */\nconstructor(private _scrollDispatcher: ScrollDispatcher) { }\n/**\n * @param {?} overlayRef\n * @return {?}\n */\nattach(overlayRef: OverlayRef) {\r\n    if (this._overlayRef) {\r\n      throw getMdScrollStrategyAlreadyAttachedError();\r\n    }\r\n\r\n    this._overlayRef = overlayRef;\r\n  }\n/**\n * @return {?}\n */\nenable() {\r\n    if (!this._scrollSubscription) {\r\n      this._scrollSubscription = this._scrollDispatcher.scrolled(0, () => {\r\n        if (this._overlayRef.hasAttached()) {\r\n          this._overlayRef.detach();\r\n        }\r\n\r\n        this.disable();\r\n      });\r\n    }\r\n  }\n/**\n * @return {?}\n */\ndisable() {\r\n    if (this._scrollSubscription) {\r\n      this._scrollSubscription.unsubscribe();\r\n      this._scrollSubscription = null;\r\n    }\r\n  }\r\n}\n\nfunction CloseScrollStrategy_tsickle_Closure_declarations() {\n/** @type {?} */\nCloseScrollStrategy.prototype._scrollSubscription;\n/** @type {?} */\nCloseScrollStrategy.prototype._overlayRef;\n/** @type {?} */\nCloseScrollStrategy.prototype._scrollDispatcher;\n}\n\r\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {\r\n  Directive,\r\n  ElementRef,\r\n  EventEmitter,\r\n  Inject,\r\n  InjectionToken,\r\n  Input,\r\n  OnChanges,\r\n  OnDestroy,\r\n  Optional,\r\n  Output,\r\n  Renderer2,\r\n  SimpleChanges,\r\n  TemplateRef,\r\n  ViewContainerRef,\r\n} from '@angular/core';\r\nimport {Direction, Directionality} from '@angular/cdk/bidi';\r\nimport {coerceBooleanProperty} from '@angular/cdk/coercion';\r\nimport {ESCAPE} from '@angular/cdk/keycodes';\r\nimport {TemplatePortal} from '@angular/cdk/portal';\r\nimport {Overlay} from './overlay';\r\nimport {OverlayRef} from './overlay-ref';\r\nimport {OverlayState} from './overlay-state';\r\nimport {\r\n  // This import is only used to define a generic type. The current TypeScript version incorrectly\r\n  // considers such imports as unused (https://github.com/Microsoft/TypeScript/issues/14953)\r\n  // tslint:disable-next-line:no-unused-variable\r\n  ConnectedOverlayPositionChange,\r\n  ConnectionPositionPair,\r\n} from './position/connected-position';\r\nimport {ConnectedPositionStrategy} from './position/connected-position-strategy';\r\nimport {RepositionScrollStrategy, ScrollStrategy} from './scroll/index';\r\nimport {Subscription} from 'rxjs/Subscription';\n/**\n * Default set of positions for the overlay. Follows the behavior of a dropdown.\n */\nconst defaultPositionList = [\r\n  new ConnectionPositionPair(\r\n      {originX: 'start', originY: 'bottom'},\r\n      {overlayX: 'start', overlayY: 'top'}),\r\n  new ConnectionPositionPair(\r\n      {originX: 'start', originY: 'top'},\r\n      {overlayX: 'start', overlayY: 'bottom'}),\r\n];\n/**\n * Injection token that determines the scroll handling while the connected overlay is open.\n */\nexport const MD_CONNECTED_OVERLAY_SCROLL_STRATEGY =\r\n    new InjectionToken<() => ScrollStrategy>('md-connected-overlay-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\nexport function MD_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay: Overlay):\r\n    () => RepositionScrollStrategy {\r\n  return () => overlay.scrollStrategies.reposition();\r\n}\n/**\n * \\@docs-private\n */\nexport const MD_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {\r\n  provide: MD_CONNECTED_OVERLAY_SCROLL_STRATEGY,\r\n  deps: [Overlay],\r\n  useFactory: MD_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY,\r\n};\n/**\n * Directive applied to an element to make it usable as an origin for an Overlay using a\rConnectedPositionStrategy.\n */\nexport class OverlayOrigin {\n/**\n * @param {?} elementRef\n */\nconstructor(public elementRef: ElementRef) { }\r\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{\r\n  selector: '[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]',\r\n  exportAs: 'cdkOverlayOrigin',\r\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ElementRef, },\n];\n}\n\nfunction OverlayOrigin_tsickle_Closure_declarations() {\n/** @type {?} */\nOverlayOrigin.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nOverlayOrigin.ctorParameters;\n/** @type {?} */\nOverlayOrigin.prototype.elementRef;\n}\n\n/**\n * Directive to facilitate declarative creation of an Overlay using a ConnectedPositionStrategy.\n */\nexport class ConnectedOverlayDirective implements OnDestroy, OnChanges {\nprivate _overlayRef: OverlayRef;\nprivate _templatePortal: TemplatePortal<any>;\nprivate _hasBackdrop = false;\nprivate _backdropSubscription = Subscription.EMPTY;\nprivate _positionSubscription = Subscription.EMPTY;\nprivate _offsetX: number = 0;\nprivate _offsetY: number = 0;\nprivate _position: ConnectedPositionStrategy;\nprivate _escapeListener = () => {};\n/**\n * Origin for the connected overlay.\n */\norigin: OverlayOrigin;\n/**\n * Registered connected position pairs.\n */\npositions: ConnectionPositionPair[];\n/**\n * The offset in pixels for the overlay connection point on the x-axis\n * @return {?}\n */\nget offsetX(): number { return this._offsetX; }\n/**\n * @param {?} offsetX\n * @return {?}\n */\nset offsetX(offsetX: number) {\r\n    this._offsetX = offsetX;\r\n    if (this._position) {\r\n      this._position.withOffsetX(offsetX);\r\n    }\r\n  }\n/**\n * The offset in pixels for the overlay connection point on the y-axis\n * @return {?}\n */\nget offsetY() { return this._offsetY; }\n/**\n * @param {?} offsetY\n * @return {?}\n */\nset offsetY(offsetY: number) {\r\n    this._offsetY = offsetY;\r\n    if (this._position) {\r\n      this._position.withOffsetY(offsetY);\r\n    }\r\n  }\n/**\n * The width of the overlay panel.\n */\nwidth: number | string;\n/**\n * The height of the overlay panel.\n */\nheight: number | string;\n/**\n * The min width of the overlay panel.\n */\nminWidth: number | string;\n/**\n * The min height of the overlay panel.\n */\nminHeight: number | string;\n/**\n * The custom class to be set on the backdrop element.\n */\nbackdropClass: string;\n/**\n * Strategy to be used when handling scroll events while the overlay is open.\n */\nscrollStrategy: ScrollStrategy =\r\n      this._scrollStrategy();\n/**\n * Whether the overlay is open.\n */\nopen: boolean = false;\n/**\n * Whether or not the overlay should attach a backdrop.\n * @return {?}\n */\nget hasBackdrop() { return this._hasBackdrop; }\n/**\n * @param {?} value\n * @return {?}\n */\nset hasBackdrop(value: any) { this._hasBackdrop = coerceBooleanProperty(value); }\n/**\n * @deprecated\n * @return {?}\n */\nget _deprecatedOrigin(): OverlayOrigin { return this.origin; }\n/**\n * @param {?} _origin\n * @return {?}\n */\nset _deprecatedOrigin(_origin: OverlayOrigin) { this.origin = _origin; }\n/**\n * @deprecated\n * @return {?}\n */\nget _deprecatedPositions(): ConnectionPositionPair[] { return this.positions; }\n/**\n * @param {?} _positions\n * @return {?}\n */\nset _deprecatedPositions(_positions: ConnectionPositionPair[]) { this.positions = _positions; }\n/**\n * @deprecated\n * @return {?}\n */\nget _deprecatedOffsetX(): number { return this.offsetX; }\n/**\n * @param {?} _offsetX\n * @return {?}\n */\nset _deprecatedOffsetX(_offsetX: number) { this.offsetX = _offsetX; }\n/**\n * @deprecated\n * @return {?}\n */\nget _deprecatedOffsetY(): number { return this.offsetY; }\n/**\n * @param {?} _offsetY\n * @return {?}\n */\nset _deprecatedOffsetY(_offsetY: number) { this.offsetY = _offsetY; }\n/**\n * @deprecated\n * @return {?}\n */\nget _deprecatedWidth(): number | string { return this.width; }\n/**\n * @param {?} _width\n * @return {?}\n */\nset _deprecatedWidth(_width: number | string) { this.width = _width; }\n/**\n * @deprecated\n * @return {?}\n */\nget _deprecatedHeight(): number | string { return this.height; }\n/**\n * @param {?} _height\n * @return {?}\n */\nset _deprecatedHeight(_height: number | string) { this.height = _height; }\n/**\n * @deprecated\n * @return {?}\n */\nget _deprecatedMinWidth(): number | string { return this.minWidth; }\n/**\n * @param {?} _minWidth\n * @return {?}\n */\nset _deprecatedMinWidth(_minWidth: number | string) { this.minWidth = _minWidth; }\n/**\n * @deprecated\n * @return {?}\n */\nget _deprecatedMinHeight(): number | string { return this.minHeight; }\n/**\n * @param {?} _minHeight\n * @return {?}\n */\nset _deprecatedMinHeight(_minHeight: number | string) { this.minHeight = _minHeight; }\n/**\n * @deprecated\n * @return {?}\n */\nget _deprecatedBackdropClass(): string { return this.backdropClass; }\n/**\n * @param {?} _backdropClass\n * @return {?}\n */\nset _deprecatedBackdropClass(_backdropClass: string) { this.backdropClass = _backdropClass; }\n/**\n * @deprecated\n * @return {?}\n */\nget _deprecatedScrollStrategy(): ScrollStrategy { return this.scrollStrategy; }\n/**\n * @param {?} _scrollStrategy\n * @return {?}\n */\nset _deprecatedScrollStrategy(_scrollStrategy: ScrollStrategy) {\r\n    this.scrollStrategy = _scrollStrategy;\r\n  }\n/**\n * @deprecated\n * @return {?}\n */\nget _deprecatedOpen(): boolean { return this.open; }\n/**\n * @param {?} _open\n * @return {?}\n */\nset _deprecatedOpen(_open: boolean) { this.open = _open; }\n/**\n * @deprecated\n * @return {?}\n */\nget _deprecatedHasBackdrop() { return this.hasBackdrop; }\n/**\n * @param {?} _hasBackdrop\n * @return {?}\n */\nset _deprecatedHasBackdrop(_hasBackdrop: any) { this.hasBackdrop = _hasBackdrop; }\n/**\n * Event emitted when the backdrop is clicked.\n */\nbackdropClick = new EventEmitter<void>();\n/**\n * Event emitted when the position has changed.\n */\npositionChange = new EventEmitter<ConnectedOverlayPositionChange>();\n/**\n * Event emitted when the overlay has been attached.\n */\nattach = new EventEmitter<void>();\n/**\n * Event emitted when the overlay has been detached.\n */\ndetach = new EventEmitter<void>();\n/**\n * @param {?} _overlay\n * @param {?} _renderer\n * @param {?} templateRef\n * @param {?} viewContainerRef\n * @param {?} _scrollStrategy\n * @param {?} _dir\n */\nconstructor(\nprivate _overlay: Overlay,\nprivate _renderer: Renderer2,\r\n      templateRef: TemplateRef<any>,\r\n      viewContainerRef: ViewContainerRef,\nprivate _scrollStrategy,\nprivate _dir: Directionality) {\r\n    this._templatePortal = new TemplatePortal(templateRef, viewContainerRef);\r\n  }\n/**\n * The associated overlay reference.\n * @return {?}\n */\nget overlayRef(): OverlayRef {\r\n    return this._overlayRef;\r\n  }\n/**\n * The element's layout direction.\n * @return {?}\n */\nget dir(): Direction {\r\n    return this._dir ? this._dir.value : 'ltr';\r\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\r\n    this._destroyOverlay();\r\n  }\n/**\n * @param {?} changes\n * @return {?}\n */\nngOnChanges(changes: SimpleChanges) {\r\n    if (changes['open'] || changes['_deprecatedOpen']) {\r\n      this.open ? this._attachOverlay() : this._detachOverlay();\r\n    }\r\n  }\n/**\n * Creates an overlay\n * @return {?}\n */\nprivate _createOverlay() {\r\n    if (!this.positions || !this.positions.length) {\r\n      this.positions = defaultPositionList;\r\n    }\r\n\r\n    this._overlayRef = this._overlay.create(this._buildConfig());\r\n  }\n/**\n * Builds the overlay config based on the directive's inputs\n * @return {?}\n */\nprivate _buildConfig(): OverlayState {\r\n    const /** @type {?} */ positionStrategy = this._position = this._createPositionStrategy();\r\n    const /** @type {?} */ overlayConfig = new OverlayState({\r\n      positionStrategy,\r\n      scrollStrategy: this.scrollStrategy,\r\n      hasBackdrop: this.hasBackdrop\r\n    });\r\n\r\n    if (this.width || this.width === 0) {\r\n      overlayConfig.width = this.width;\r\n    }\r\n\r\n    if (this.height || this.height === 0) {\r\n      overlayConfig.height = this.height;\r\n    }\r\n\r\n    if (this.minWidth || this.minWidth === 0) {\r\n      overlayConfig.minWidth = this.minWidth;\r\n    }\r\n\r\n    if (this.minHeight || this.minHeight === 0) {\r\n      overlayConfig.minHeight = this.minHeight;\r\n    }\r\n\r\n    if (this.backdropClass) {\r\n      overlayConfig.backdropClass = this.backdropClass;\r\n    }\r\n\r\n    return overlayConfig;\r\n  }\n/**\n * Returns the position strategy of the overlay to be set on the overlay config\n * @return {?}\n */\nprivate _createPositionStrategy(): ConnectedPositionStrategy {\r\n    const /** @type {?} */ pos = this.positions[0];\r\n    const /** @type {?} */ originPoint = {originX: pos.originX, originY: pos.originY};\r\n    const /** @type {?} */ overlayPoint = {overlayX: pos.overlayX, overlayY: pos.overlayY};\r\n\r\n    const /** @type {?} */ strategy = this._overlay.position()\r\n      .connectedTo(this.origin.elementRef, originPoint, overlayPoint)\r\n      .withOffsetX(this.offsetX)\r\n      .withOffsetY(this.offsetY);\r\n\r\n    this._handlePositionChanges(strategy);\r\n\r\n    return strategy;\r\n  }\n/**\n * @param {?} strategy\n * @return {?}\n */\nprivate _handlePositionChanges(strategy: ConnectedPositionStrategy): void {\r\n    for (let /** @type {?} */ i = 1; i < this.positions.length; i++) {\r\n      strategy.withFallbackPosition(\r\n          {originX: this.positions[i].originX, originY: this.positions[i].originY},\r\n          {overlayX: this.positions[i].overlayX, overlayY: this.positions[i].overlayY}\r\n      );\r\n    }\r\n\r\n    this._positionSubscription =\r\n        strategy.onPositionChange.subscribe(pos => this.positionChange.emit(pos));\r\n  }\n/**\n * Attaches the overlay and subscribes to backdrop clicks if backdrop exists\n * @return {?}\n */\nprivate _attachOverlay() {\r\n    if (!this._overlayRef) {\r\n      this._createOverlay();\r\n    }\r\n\r\n    this._position.withDirection(this.dir);\r\n    this._overlayRef.getState().direction = this.dir;\r\n    this._initEscapeListener();\r\n\r\n    if (!this._overlayRef.hasAttached()) {\r\n      this._overlayRef.attach(this._templatePortal);\r\n      this.attach.emit();\r\n    }\r\n\r\n    if (this.hasBackdrop) {\r\n      this._backdropSubscription = this._overlayRef.backdropClick().subscribe(() => {\r\n        this.backdropClick.emit();\r\n      });\r\n    }\r\n  }\n/**\n * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists\n * @return {?}\n */\nprivate _detachOverlay() {\r\n    if (this._overlayRef) {\r\n      this._overlayRef.detach();\r\n      this.detach.emit();\r\n    }\r\n\r\n    this._backdropSubscription.unsubscribe();\r\n    this._escapeListener();\r\n  }\n/**\n * Destroys the overlay created by this directive.\n * @return {?}\n */\nprivate _destroyOverlay() {\r\n    if (this._overlayRef) {\r\n      this._overlayRef.dispose();\r\n    }\r\n\r\n    this._backdropSubscription.unsubscribe();\r\n    this._positionSubscription.unsubscribe();\r\n    this._escapeListener();\r\n  }\n/**\n * Sets the event listener that closes the overlay when pressing Escape.\n * @return {?}\n */\nprivate _initEscapeListener() {\r\n    this._escapeListener = this._renderer.listen('document', 'keydown', (event: KeyboardEvent) => {\r\n      if (event.keyCode === ESCAPE) {\r\n        this._detachOverlay();\r\n      }\r\n    });\r\n  }\r\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{\r\n  selector: '[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]',\r\n  exportAs: 'cdkConnectedOverlay'\r\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: Overlay, },\n{type: Renderer2, },\n{type: TemplateRef, },\n{type: ViewContainerRef, },\n{type: undefined, decorators: [{ type: Inject, args: [MD_CONNECTED_OVERLAY_SCROLL_STRATEGY, ] }, ]},\n{type: Directionality, decorators: [{ type: Optional }, ]},\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'origin': [{ type: Input, args: ['cdkConnectedOverlayOrigin', ] },],\n'positions': [{ type: Input, args: ['cdkConnectedOverlayPositions', ] },],\n'offsetX': [{ type: Input, args: ['cdkConnectedOverlayOffsetX', ] },],\n'offsetY': [{ type: Input, args: ['cdkConnectedOverlayOffsetY', ] },],\n'width': [{ type: Input, args: ['cdkConnectedOverlayWidth', ] },],\n'height': [{ type: Input, args: ['cdkConnectedOverlayHeight', ] },],\n'minWidth': [{ type: Input, args: ['cdkConnectedOverlayMinWidth', ] },],\n'minHeight': [{ type: Input, args: ['cdkConnectedOverlayMinHeight', ] },],\n'backdropClass': [{ type: Input, args: ['cdkConnectedOverlayBackdropClass', ] },],\n'scrollStrategy': [{ type: Input, args: ['cdkConnectedOverlayScrollStrategy', ] },],\n'open': [{ type: Input, args: ['cdkConnectedOverlayOpen', ] },],\n'hasBackdrop': [{ type: Input, args: ['cdkConnectedOverlayHasBackdrop', ] },],\n'_deprecatedOrigin': [{ type: Input, args: ['origin', ] },],\n'_deprecatedPositions': [{ type: Input, args: ['positions', ] },],\n'_deprecatedOffsetX': [{ type: Input, args: ['offsetX', ] },],\n'_deprecatedOffsetY': [{ type: Input, args: ['offsetY', ] },],\n'_deprecatedWidth': [{ type: Input, args: ['width', ] },],\n'_deprecatedHeight': [{ type: Input, args: ['height', ] },],\n'_deprecatedMinWidth': [{ type: Input, args: ['minWidth', ] },],\n'_deprecatedMinHeight': [{ type: Input, args: ['minHeight', ] },],\n'_deprecatedBackdropClass': [{ type: Input, args: ['backdropClass', ] },],\n'_deprecatedScrollStrategy': [{ type: Input, args: ['scrollStrategy', ] },],\n'_deprecatedOpen': [{ type: Input, args: ['open', ] },],\n'_deprecatedHasBackdrop': [{ type: Input, args: ['hasBackdrop', ] },],\n'backdropClick': [{ type: Output },],\n'positionChange': [{ type: Output },],\n'attach': [{ type: Output },],\n'detach': [{ type: Output },],\n};\n}\n\nfunction ConnectedOverlayDirective_tsickle_Closure_declarations() {\n/** @type {?} */\nConnectedOverlayDirective.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nConnectedOverlayDirective.ctorParameters;\n/** @type {?} */\nConnectedOverlayDirective.propDecorators;\n/** @type {?} */\nConnectedOverlayDirective.prototype._overlayRef;\n/** @type {?} */\nConnectedOverlayDirective.prototype._templatePortal;\n/** @type {?} */\nConnectedOverlayDirective.prototype._hasBackdrop;\n/** @type {?} */\nConnectedOverlayDirective.prototype._backdropSubscription;\n/** @type {?} */\nConnectedOverlayDirective.prototype._positionSubscription;\n/** @type {?} */\nConnectedOverlayDirective.prototype._offsetX;\n/** @type {?} */\nConnectedOverlayDirective.prototype._offsetY;\n/** @type {?} */\nConnectedOverlayDirective.prototype._position;\n/** @type {?} */\nConnectedOverlayDirective.prototype._escapeListener;\n/**\n * Origin for the connected overlay.\n * @type {?}\n */\nConnectedOverlayDirective.prototype.origin;\n/**\n * Registered connected position pairs.\n * @type {?}\n */\nConnectedOverlayDirective.prototype.positions;\n/**\n * The width of the overlay panel.\n * @type {?}\n */\nConnectedOverlayDirective.prototype.width;\n/**\n * The height of the overlay panel.\n * @type {?}\n */\nConnectedOverlayDirective.prototype.height;\n/**\n * The min width of the overlay panel.\n * @type {?}\n */\nConnectedOverlayDirective.prototype.minWidth;\n/**\n * The min height of the overlay panel.\n * @type {?}\n */\nConnectedOverlayDirective.prototype.minHeight;\n/**\n * The custom class to be set on the backdrop element.\n * @type {?}\n */\nConnectedOverlayDirective.prototype.backdropClass;\n/**\n * Strategy to be used when handling scroll events while the overlay is open.\n * @type {?}\n */\nConnectedOverlayDirective.prototype.scrollStrategy;\n/**\n * Whether the overlay is open.\n * @type {?}\n */\nConnectedOverlayDirective.prototype.open;\n/**\n * Event emitted when the backdrop is clicked.\n * @type {?}\n */\nConnectedOverlayDirective.prototype.backdropClick;\n/**\n * Event emitted when the position has changed.\n * @type {?}\n */\nConnectedOverlayDirective.prototype.positionChange;\n/**\n * Event emitted when the overlay has been attached.\n * @type {?}\n */\nConnectedOverlayDirective.prototype.attach;\n/**\n * Event emitted when the overlay has been detached.\n * @type {?}\n */\nConnectedOverlayDirective.prototype.detach;\n/** @type {?} */\nConnectedOverlayDirective.prototype._overlay;\n/** @type {?} */\nConnectedOverlayDirective.prototype._renderer;\n/** @type {?} */\nConnectedOverlayDirective.prototype._scrollStrategy;\n/** @type {?} */\nConnectedOverlayDirective.prototype._dir;\n}\n\r\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {ScrollStrategy} from './scroll-strategy';\n/**\n * Scroll strategy that doesn't do anything.\n */\nexport class NoopScrollStrategy implements ScrollStrategy {\n/**\n * @return {?}\n */\nenable() { }\n/**\n * @return {?}\n */\ndisable() { }\n/**\n * @return {?}\n */\nattach() { }\r\n}\r\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {PositionStrategy} from './position/position-strategy';\r\nimport {Direction} from '@angular/cdk/bidi';\r\nimport {ScrollStrategy} from './scroll/scroll-strategy';\r\nimport {NoopScrollStrategy} from './scroll/noop-scroll-strategy';\n/**\n * OverlayState is a bag of values for either the initial configuration or current state of an\roverlay.\n */\nexport class OverlayState {\n/**\n * Strategy with which to position the overlay.\n */\npositionStrategy?: PositionStrategy;\n/**\n * Strategy to be used when handling scroll events while the overlay is open.\n */\nscrollStrategy?: ScrollStrategy = new NoopScrollStrategy();\n/**\n * Custom class to add to the overlay pane.\n */\npanelClass?: string | string[] = '';\n/**\n * Whether the overlay has a backdrop.\n */\nhasBackdrop?: boolean = false;\n/**\n * Custom class to add to the backdrop\n */\nbackdropClass?: string = 'cdk-overlay-dark-backdrop';\n/**\n * The width of the overlay panel. If a number is provided, pixel units are assumed.\n */\nwidth?: number | string;\n/**\n * The height of the overlay panel. If a number is provided, pixel units are assumed.\n */\nheight?: number | string;\n/**\n * The min-width of the overlay panel. If a number is provided, pixel units are assumed.\n */\nminWidth?: number | string;\n/**\n * The min-height of the overlay panel. If a number is provided, pixel units are assumed.\n */\nminHeight?: number | string;\n/**\n * The max-width of the overlay panel. If a number is provided, pixel units are assumed.\n */\nmaxWidth?: number | string;\n/**\n * The max-height of the overlay panel. If a number is provided, pixel units are assumed.\n */\nmaxHeight?: number | string;\n/**\n * The direction of the text in the overlay panel.\n */\ndirection?: Direction = 'ltr';\n/**\n * @param {?=} state\n */\nconstructor(state?: OverlayState) {\r\n    if (state) {\r\n      Object.keys(state).forEach(key => this[key] = state[key]);\r\n    }\r\n  }\r\n\r\n  // TODO(jelbourn): configuration still to add\r\n  // - focus trap\r\n  // - disable pointer events\r\n  // - z-index\r\n}\n\nfunction OverlayState_tsickle_Closure_declarations() {\n/**\n * Strategy with which to position the overlay.\n * @type {?}\n */\nOverlayState.prototype.positionStrategy;\n/**\n * Strategy to be used when handling scroll events while the overlay is open.\n * @type {?}\n */\nOverlayState.prototype.scrollStrategy;\n/**\n * Custom class to add to the overlay pane.\n * @type {?}\n */\nOverlayState.prototype.panelClass;\n/**\n * Whether the overlay has a backdrop.\n * @type {?}\n */\nOverlayState.prototype.hasBackdrop;\n/**\n * Custom class to add to the backdrop\n * @type {?}\n */\nOverlayState.prototype.backdropClass;\n/**\n * The width of the overlay panel. If a number is provided, pixel units are assumed.\n * @type {?}\n */\nOverlayState.prototype.width;\n/**\n * The height of the overlay panel. If a number is provided, pixel units are assumed.\n * @type {?}\n */\nOverlayState.prototype.height;\n/**\n * The min-width of the overlay panel. If a number is provided, pixel units are assumed.\n * @type {?}\n */\nOverlayState.prototype.minWidth;\n/**\n * The min-height of the overlay panel. If a number is provided, pixel units are assumed.\n * @type {?}\n */\nOverlayState.prototype.minHeight;\n/**\n * The max-width of the overlay panel. If a number is provided, pixel units are assumed.\n * @type {?}\n */\nOverlayState.prototype.maxWidth;\n/**\n * The max-height of the overlay panel. If a number is provided, pixel units are assumed.\n * @type {?}\n */\nOverlayState.prototype.maxHeight;\n/**\n * The direction of the text in the overlay panel.\n * @type {?}\n */\nOverlayState.prototype.direction;\n}\n\r\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {NgZone} from '@angular/core';\r\nimport {PortalHost, Portal} from '@angular/cdk/portal';\r\nimport {OverlayState} from './overlay-state';\r\nimport {Observable} from 'rxjs/Observable';\r\nimport {Subject} from 'rxjs/Subject';\n/**\n * Reference to an overlay that has been created with the Overlay service.\rUsed to manipulate or dispose of said overlay.\n */\nexport class OverlayRef implements PortalHost {\nprivate _backdropElement: HTMLElement | null = null;\nprivate _backdropClick: Subject<any> = new Subject();\nprivate _attachments = new Subject<void>();\nprivate _detachments = new Subject<void>();\n/**\n * @param {?} _portalHost\n * @param {?} _pane\n * @param {?} _state\n * @param {?} _ngZone\n */\nconstructor(\nprivate _portalHost: PortalHost,\nprivate _pane: HTMLElement,\nprivate _state: OverlayState,\nprivate _ngZone: NgZone) {\r\n\r\n    if (_state.scrollStrategy) {\r\n      _state.scrollStrategy.attach(this);\r\n    }\r\n  }\n/**\n * The overlay's HTML element\n * @return {?}\n */\nget overlayElement(): HTMLElement {\r\n    return this._pane;\r\n  }\n/**\n * Attaches the overlay to a portal instance and adds the backdrop.\r\\@param portal Portal instance to which to attach the overlay.\r\\@returns The portal attachment result.\n * @param {?} portal\n * @return {?}\n */\nattach(portal: Portal<any>): any {\r\n    let /** @type {?} */ attachResult = this._portalHost.attach(portal);\r\n\r\n    if (this._state.positionStrategy) {\r\n      this._state.positionStrategy.attach(this);\r\n    }\r\n\r\n    // Update the pane element with the given state configuration.\r\n    this._updateStackingOrder();\r\n    this.updateSize();\r\n    this.updateDirection();\r\n    this.updatePosition();\r\n\r\n    if (this._state.scrollStrategy) {\r\n      this._state.scrollStrategy.enable();\r\n    }\r\n\r\n    // Enable pointer events for the overlay pane element.\r\n    this._togglePointerEvents(true);\r\n\r\n    if (this._state.hasBackdrop) {\r\n      this._attachBackdrop();\r\n    }\r\n\r\n    if (this._state.panelClass) {\r\n      // We can't do a spread here, because IE doesn't support setting multiple classes.\r\n      if (Array.isArray(this._state.panelClass)) {\r\n        this._state.panelClass.forEach(cls => this._pane.classList.add(cls));\r\n      } else {\r\n        this._pane.classList.add(this._state.panelClass);\r\n      }\r\n    }\r\n\r\n    // Only emit the `attachments` event once all other setup is done.\r\n    this._attachments.next();\r\n\r\n    return attachResult;\r\n  }\n/**\n * Detaches an overlay from a portal.\r\\@returns Resolves when the overlay has been detached.\n * @return {?}\n */\ndetach(): Promise<any> {\r\n    this.detachBackdrop();\r\n\r\n    // When the overlay is detached, the pane element should disable pointer events.\r\n    // This is necessary because otherwise the pane element will cover the page and disable\r\n    // pointer events therefore. Depends on the position strategy and the applied pane boundaries.\r\n    this._togglePointerEvents(false);\r\n\r\n    if (this._state.scrollStrategy) {\r\n      this._state.scrollStrategy.disable();\r\n    }\r\n\r\n    let /** @type {?} */ detachmentResult = this._portalHost.detach();\r\n\r\n    // Only emit after everything is detached.\r\n    this._detachments.next();\r\n\r\n    return detachmentResult;\r\n  }\n/**\n * Cleans up the overlay from the DOM.\n * @return {?}\n */\ndispose(): void {\r\n    if (this._state.positionStrategy) {\r\n      this._state.positionStrategy.dispose();\r\n    }\r\n\r\n    if (this._state.scrollStrategy) {\r\n      this._state.scrollStrategy.disable();\r\n    }\r\n\r\n    this.detachBackdrop();\r\n    this._portalHost.dispose();\r\n    this._attachments.complete();\r\n    this._backdropClick.complete();\r\n    this._detachments.next();\r\n    this._detachments.complete();\r\n  }\n/**\n * Checks whether the overlay has been attached.\n * @return {?}\n */\nhasAttached(): boolean {\r\n    return this._portalHost.hasAttached();\r\n  }\n/**\n * Returns an observable that emits when the backdrop has been clicked.\n * @return {?}\n */\nbackdropClick(): Observable<void> {\r\n    return this._backdropClick.asObservable();\r\n  }\n/**\n * Returns an observable that emits when the overlay has been attached.\n * @return {?}\n */\nattachments(): Observable<void> {\r\n    return this._attachments.asObservable();\r\n  }\n/**\n * Returns an observable that emits when the overlay has been detached.\n * @return {?}\n */\ndetachments(): Observable<void> {\r\n    return this._detachments.asObservable();\r\n  }\n/**\n * Gets the current state config of the overlay.\n * @return {?}\n */\ngetState(): OverlayState {\r\n    return this._state;\r\n  }\n/**\n * Updates the position of the overlay based on the position strategy.\n * @return {?}\n */\nupdatePosition() {\r\n    if (this._state.positionStrategy) {\r\n      this._state.positionStrategy.apply();\r\n    }\r\n  }\n/**\n * Updates the text direction of the overlay panel.\n * @return {?}\n */\nprivate updateDirection() {\r\n    this._pane.setAttribute('dir', /** @type {?} */(( this._state.direction)));\r\n  }\n/**\n * Updates the size of the overlay based on the overlay config.\n * @return {?}\n */\nupdateSize() {\r\n    if (this._state.width || this._state.width === 0) {\r\n      this._pane.style.width = formatCssUnit(this._state.width);\r\n    }\r\n\r\n    if (this._state.height || this._state.height === 0) {\r\n      this._pane.style.height = formatCssUnit(this._state.height);\r\n    }\r\n\r\n    if (this._state.minWidth || this._state.minWidth === 0) {\r\n      this._pane.style.minWidth = formatCssUnit(this._state.minWidth);\r\n    }\r\n\r\n    if (this._state.minHeight || this._state.minHeight === 0) {\r\n      this._pane.style.minHeight = formatCssUnit(this._state.minHeight);\r\n    }\r\n\r\n    if (this._state.maxWidth || this._state.maxWidth === 0) {\r\n      this._pane.style.maxWidth = formatCssUnit(this._state.maxWidth);\r\n    }\r\n\r\n    if (this._state.maxHeight || this._state.maxHeight === 0) {\r\n      this._pane.style.maxHeight = formatCssUnit(this._state.maxHeight);\r\n    }\r\n  }\n/**\n * Toggles the pointer events for the overlay pane element.\n * @param {?} enablePointer\n * @return {?}\n */\nprivate _togglePointerEvents(enablePointer: boolean) {\r\n    this._pane.style.pointerEvents = enablePointer ? 'auto' : 'none';\r\n  }\n/**\n * Attaches a backdrop for this overlay.\n * @return {?}\n */\nprivate _attachBackdrop() {\r\n    this._backdropElement = document.createElement('div');\r\n    this._backdropElement.classList.add('cdk-overlay-backdrop');\r\n\r\n    if (this._state.backdropClass) {\r\n      this._backdropElement.classList.add(this._state.backdropClass);\r\n    } /** @type {?} */((\r\n\r\n    // Insert the backdrop before the pane in the DOM order,\r\n    // in order to handle stacked overlays properly.\r\n    this._pane.parentElement)).insertBefore(this._backdropElement, this._pane);\r\n\r\n    // Forward backdrop clicks such that the consumer of the overlay can perform whatever\r\n    // action desired when such a click occurs (usually closing the overlay).\r\n    this._backdropElement.addEventListener('click', () => this._backdropClick.next(null));\r\n\r\n    // Add class to fade-in the backdrop after one frame.\r\n    requestAnimationFrame(() => {\r\n      if (this._backdropElement) {\r\n        this._backdropElement.classList.add('cdk-overlay-backdrop-showing');\r\n      }\r\n    });\r\n  }\n/**\n * Updates the stacking order of the element, moving it to the top if necessary.\rThis is required in cases where one overlay was detached, while another one,\rthat should be behind it, was destroyed. The next time both of them are opened,\rthe stacking will be wrong, because the detached element's pane will still be\rin its original DOM position.\n * @return {?}\n */\nprivate _updateStackingOrder() {\r\n    if (this._pane.nextSibling) { /** @type {?} */((\r\n      this._pane.parentNode)).appendChild(this._pane);\r\n    }\r\n  }\n/**\n * Detaches the backdrop (if any) associated with the overlay.\n * @return {?}\n */\ndetachBackdrop(): void {\r\n    let /** @type {?} */ backdropToDetach = this._backdropElement;\r\n\r\n    if (backdropToDetach) {\r\n      let /** @type {?} */ finishDetach = () => {\r\n        // It may not be attached to anything in certain cases (e.g. unit tests).\r\n        if (backdropToDetach && backdropToDetach.parentNode) {\r\n          backdropToDetach.parentNode.removeChild(backdropToDetach);\r\n        }\r\n\r\n        // It is possible that a new portal has been attached to this overlay since we started\r\n        // removing the backdrop. If that is the case, only clear the backdrop reference if it\r\n        // is still the same instance that we started to remove.\r\n        if (this._backdropElement == backdropToDetach) {\r\n          this._backdropElement = null;\r\n        }\r\n      };\r\n\r\n      backdropToDetach.classList.remove('cdk-overlay-backdrop-showing');\r\n\r\n      if (this._state.backdropClass) {\r\n        backdropToDetach.classList.remove(this._state.backdropClass);\r\n      }\r\n\r\n      backdropToDetach.addEventListener('transitionend', finishDetach);\r\n\r\n      // If the backdrop doesn't have a transition, the `transitionend` event won't fire.\r\n      // In this case we make it unclickable and we try to remove it after a delay.\r\n      backdropToDetach.style.pointerEvents = 'none';\r\n\r\n      // Run this outside the Angular zone because there's nothing that Angular cares about.\r\n      // If it were to run inside the Angular zone, every test that used Overlay would have to be\r\n      // either async or fakeAsync.\r\n      this._ngZone.runOutsideAngular(() => {\r\n        setTimeout(finishDetach, 500);\r\n      });\r\n    }\r\n  }\r\n}\n\nfunction OverlayRef_tsickle_Closure_declarations() {\n/** @type {?} */\nOverlayRef.prototype._backdropElement;\n/** @type {?} */\nOverlayRef.prototype._backdropClick;\n/** @type {?} */\nOverlayRef.prototype._attachments;\n/** @type {?} */\nOverlayRef.prototype._detachments;\n/** @type {?} */\nOverlayRef.prototype._portalHost;\n/** @type {?} */\nOverlayRef.prototype._pane;\n/** @type {?} */\nOverlayRef.prototype._state;\n/** @type {?} */\nOverlayRef.prototype._ngZone;\n}\n\n/**\n * @param {?} value\n * @return {?}\n */\nfunction formatCssUnit(value: number | string) {\r\n  return typeof value === 'string' ? /** @type {?} */(( value as string)) : `${value}px`;\r\n}\r\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/** Horizontal dimension of a connection point on the perimeter of the origin or overlay element. */\r\n\nimport {Optional} from '@angular/core';\r\nexport type HorizontalConnectionPos = 'start' | 'center' | 'end';\r\n\r\n/** Vertical dimension of a connection point on the perimeter of the origin or overlay element. */\r\nexport type VerticalConnectionPos = 'top' | 'center' | 'bottom';\r\n\r\n\r\n/** A connection point on the origin element. */\r\nexport interface OriginConnectionPosition {\r\n  originX: HorizontalConnectionPos;\r\n  originY: VerticalConnectionPos;\r\n}\r\n\r\n/** A connection point on the overlay element. */\r\nexport interface OverlayConnectionPosition {\r\n  overlayX: HorizontalConnectionPos;\r\n  overlayY: VerticalConnectionPos;\r\n}\n/**\n * The points of the origin element and the overlay element to connect.\n */\nexport class ConnectionPositionPair {\r\n  originX: HorizontalConnectionPos;\r\n  originY: VerticalConnectionPos;\r\n  overlayX: HorizontalConnectionPos;\r\n  overlayY: VerticalConnectionPos;\n/**\n * @param {?} origin\n * @param {?} overlay\n */\nconstructor(origin: OriginConnectionPosition, overlay: OverlayConnectionPosition) {\r\n    this.originX = origin.originX;\r\n    this.originY = origin.originY;\r\n    this.overlayX = overlay.overlayX;\r\n    this.overlayY = overlay.overlayY;\r\n  }\r\n}\n\nfunction ConnectionPositionPair_tsickle_Closure_declarations() {\n/** @type {?} */\nConnectionPositionPair.prototype.originX;\n/** @type {?} */\nConnectionPositionPair.prototype.originY;\n/** @type {?} */\nConnectionPositionPair.prototype.overlayX;\n/** @type {?} */\nConnectionPositionPair.prototype.overlayY;\n}\n\n/**\n * Set of properties regarding the position of the origin and overlay relative to the viewport\rwith respect to the containing Scrollable elements.\r\rThe overlay and origin are clipped if any part of their bounding client rectangle exceeds the\rbounds of any one of the strategy's Scrollable's bounding client rectangle.\r\rThe overlay and origin are outside view if there is no overlap between their bounding client\rrectangle and any one of the strategy's Scrollable's bounding client rectangle.\r\r      -----------                    -----------\r      | outside |                    | clipped |\r      |  view   |              --------------------------\r      |         |              |     |         |        |\r      ----------               |     -----------        |\r --------------------------    |                        |\r |                        |    |      Scrollable        |\r |                        |    |                        |\r |                        |     --------------------------\r |      Scrollable        |\r |                        |\r --------------------------\n */\nexport class ScrollingVisibility {\r\n  isOriginClipped: boolean;\r\n  isOriginOutsideView: boolean;\r\n  isOverlayClipped: boolean;\r\n  isOverlayOutsideView: boolean;\r\n}\n\nfunction ScrollingVisibility_tsickle_Closure_declarations() {\n/** @type {?} */\nScrollingVisibility.prototype.isOriginClipped;\n/** @type {?} */\nScrollingVisibility.prototype.isOriginOutsideView;\n/** @type {?} */\nScrollingVisibility.prototype.isOverlayClipped;\n/** @type {?} */\nScrollingVisibility.prototype.isOverlayOutsideView;\n}\n\n/**\n * The change event emitted by the strategy when a fallback position is used.\n */\nexport class ConnectedOverlayPositionChange {\n/**\n * @param {?} connectionPair\n * @param {?} scrollableViewProperties\n */\nconstructor(public connectionPair: ConnectionPositionPair,\npublic scrollableViewProperties: ScrollingVisibility) {}\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ConnectionPositionPair, },\n{type: ScrollingVisibility, decorators: [{ type: Optional }, ]},\n];\n}\n\nfunction ConnectedOverlayPositionChange_tsickle_Closure_declarations() {\n/**\n * @nocollapse\n * @type {?}\n */\nConnectedOverlayPositionChange.ctorParameters;\n/** @type {?} */\nConnectedOverlayPositionChange.prototype.connectionPair;\n/** @type {?} */\nConnectedOverlayPositionChange.prototype.scrollableViewProperties;\n}\n\r\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {PositionStrategy} from './position-strategy';\r\nimport {OverlayRef} from '../overlay-ref';\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\rexplicit position relative to the browser's viewport. We use flexbox, instead of\rtransforms, in order to avoid issues with subpixel rendering which can cause the\relement to become blurry.\n */\nexport class GlobalPositionStrategy implements PositionStrategy {\n/**\n * The overlay to which this strategy is attached.\n */\nprivate _overlayRef: OverlayRef;\nprivate _cssPosition: string = 'static';\nprivate _topOffset: string = '';\nprivate _bottomOffset: string = '';\nprivate _leftOffset: string = '';\nprivate _rightOffset: string = '';\nprivate _alignItems: string = '';\nprivate _justifyContent: string = '';\nprivate _width: string = '';\nprivate _height: string = '';\nprivate _wrapper: HTMLElement | null = null;\n/**\n * @param {?} overlayRef\n * @return {?}\n */\nattach(overlayRef: OverlayRef): void {\r\n    this._overlayRef = overlayRef;\r\n  }\n/**\n * Sets the top position of the overlay. Clears any previously set vertical position.\r\\@param value New top offset.\n * @param {?=} value\n * @return {?}\n */\ntop(value = ''): this {\r\n    this._bottomOffset = '';\r\n    this._topOffset = value;\r\n    this._alignItems = 'flex-start';\r\n    return this;\r\n  }\n/**\n * Sets the left position of the overlay. Clears any previously set horizontal position.\r\\@param value New left offset.\n * @param {?=} value\n * @return {?}\n */\nleft(value = ''): this {\r\n    this._rightOffset = '';\r\n    this._leftOffset = value;\r\n    this._justifyContent = 'flex-start';\r\n    return this;\r\n  }\n/**\n * Sets the bottom position of the overlay. Clears any previously set vertical position.\r\\@param value New bottom offset.\n * @param {?=} value\n * @return {?}\n */\nbottom(value = ''): this {\r\n    this._topOffset = '';\r\n    this._bottomOffset = value;\r\n    this._alignItems = 'flex-end';\r\n    return this;\r\n  }\n/**\n * Sets the right position of the overlay. Clears any previously set horizontal position.\r\\@param value New right offset.\n * @param {?=} value\n * @return {?}\n */\nright(value = ''): this {\r\n    this._leftOffset = '';\r\n    this._rightOffset = value;\r\n    this._justifyContent = 'flex-end';\r\n    return this;\r\n  }\n/**\n * Sets the overlay width and clears any previously set width.\r\\@param value New width for the overlay\n * @param {?=} value\n * @return {?}\n */\nwidth(value = ''): this {\r\n    this._width = value;\r\n\r\n    // When the width is 100%, we should reset the `left` and the offset,\r\n    // in order to ensure that the element is flush against the viewport edge.\r\n    if (value === '100%') {\r\n      this.left('0px');\r\n    }\r\n\r\n    return this;\r\n  }\n/**\n * Sets the overlay height and clears any previously set height.\r\\@param value New height for the overlay\n * @param {?=} value\n * @return {?}\n */\nheight(value = ''): this {\r\n    this._height = value;\r\n\r\n    // When the height is 100%, we should reset the `top` and the offset,\r\n    // in order to ensure that the element is flush against the viewport edge.\r\n    if (value === '100%') {\r\n      this.top('0px');\r\n    }\r\n\r\n    return this;\r\n  }\n/**\n * Centers the overlay horizontally with an optional offset.\rClears any previously set horizontal position.\r\r\\@param offset Overlay offset from the horizontal center.\n * @param {?=} offset\n * @return {?}\n */\ncenterHorizontally(offset = ''): this {\r\n    this.left(offset);\r\n    this._justifyContent = 'center';\r\n    return this;\r\n  }\n/**\n * Centers the overlay vertically with an optional offset.\rClears any previously set vertical position.\r\r\\@param offset Overlay offset from the vertical center.\n * @param {?=} offset\n * @return {?}\n */\ncenterVertically(offset = ''): this {\r\n    this.top(offset);\r\n    this._alignItems = 'center';\r\n    return this;\r\n  }\n/**\n * Apply the position to the element.\r\\@docs-private\r\r\\@returns Resolved when the styles have been applied.\n * @return {?}\n */\napply(): void {\r\n    const /** @type {?} */ element = this._overlayRef.overlayElement;\r\n\r\n    if (!this._wrapper && element.parentNode) {\r\n      this._wrapper = document.createElement('div');\r\n      this._wrapper.classList.add('cdk-global-overlay-wrapper');\r\n      element.parentNode.insertBefore(this._wrapper, element);\r\n      this._wrapper.appendChild(element);\r\n    }\r\n\r\n    let /** @type {?} */ styles = element.style;\r\n    let /** @type {?} */ parentStyles = ( /** @type {?} */((element.parentNode as HTMLElement))).style;\r\n\r\n    styles.position = this._cssPosition;\r\n    styles.marginTop = this._topOffset;\r\n    styles.marginLeft = this._leftOffset;\r\n    styles.marginBottom = this._bottomOffset;\r\n    styles.marginRight = this._rightOffset;\r\n    styles.width = this._width;\r\n    styles.height = this._height;\r\n\r\n    parentStyles.justifyContent = this._justifyContent;\r\n    parentStyles.alignItems = this._alignItems;\r\n  }\n/**\n * Removes the wrapper element from the DOM.\n * @return {?}\n */\ndispose(): void {\r\n    if (this._wrapper && this._wrapper.parentNode) {\r\n      this._wrapper.parentNode.removeChild(this._wrapper);\r\n      this._wrapper = null;\r\n    }\r\n  }\r\n}\n\nfunction GlobalPositionStrategy_tsickle_Closure_declarations() {\n/**\n * The overlay to which this strategy is attached.\n * @type {?}\n */\nGlobalPositionStrategy.prototype._overlayRef;\n/** @type {?} */\nGlobalPositionStrategy.prototype._cssPosition;\n/** @type {?} */\nGlobalPositionStrategy.prototype._topOffset;\n/** @type {?} */\nGlobalPositionStrategy.prototype._bottomOffset;\n/** @type {?} */\nGlobalPositionStrategy.prototype._leftOffset;\n/** @type {?} */\nGlobalPositionStrategy.prototype._rightOffset;\n/** @type {?} */\nGlobalPositionStrategy.prototype._alignItems;\n/** @type {?} */\nGlobalPositionStrategy.prototype._justifyContent;\n/** @type {?} */\nGlobalPositionStrategy.prototype._width;\n/** @type {?} */\nGlobalPositionStrategy.prototype._height;\n/** @type {?} */\nGlobalPositionStrategy.prototype._wrapper;\n}\n\r\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {ElementRef, Injectable} from '@angular/core';\r\nimport {ViewportRuler} from '@angular/cdk/scrolling';\r\nimport {ConnectedPositionStrategy} from './connected-position-strategy';\r\nimport {GlobalPositionStrategy} from './global-position-strategy';\r\nimport {OverlayConnectionPosition, OriginConnectionPosition} from './connected-position';\n/**\n * Builder for overlay position strategy.\n */\nexport class OverlayPositionBuilder {\n/**\n * @param {?} _viewportRuler\n */\nconstructor(private _viewportRuler: ViewportRuler) { }\n/**\n * Creates a global position strategy.\n * @return {?}\n */\nglobal(): GlobalPositionStrategy {\r\n    return new GlobalPositionStrategy();\r\n  }\n/**\n * Creates a relative position strategy.\r\\@param elementRef\r\\@param originPos\r\\@param overlayPos\n * @param {?} elementRef\n * @param {?} originPos\n * @param {?} overlayPos\n * @return {?}\n */\nconnectedTo(\r\n      elementRef: ElementRef,\r\n      originPos: OriginConnectionPosition,\r\n      overlayPos: OverlayConnectionPosition): ConnectedPositionStrategy {\r\n    return new ConnectedPositionStrategy(originPos, overlayPos, elementRef, this._viewportRuler);\r\n  }\r\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ViewportRuler, },\n];\n}\n\nfunction OverlayPositionBuilder_tsickle_Closure_declarations() {\n/** @type {?} */\nOverlayPositionBuilder.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nOverlayPositionBuilder.ctorParameters;\n/** @type {?} */\nOverlayPositionBuilder.prototype._viewportRuler;\n}\n\r\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {Injectable, Optional, SkipSelf, OnDestroy} from '@angular/core';\n/**\n * The OverlayContainer is the container in which all overlays will load.\rIt should be provided in the root component to ensure it is properly shared.\n */\nexport class OverlayContainer implements OnDestroy {\r\n  protected _containerElement: HTMLElement;\nprivate _themeClass: string;\n/**\n * Base theme to be applied to all overlay-based components.\n * @return {?}\n */\nget themeClass(): string { return this._themeClass; }\n/**\n * @param {?} value\n * @return {?}\n */\nset themeClass(value: string) {\r\n    if (this._containerElement) {\r\n      if (this._themeClass) {\r\n        this._containerElement.classList.remove(this._themeClass);\r\n      }\r\n\r\n      if (value) {\r\n        this._containerElement.classList.add(value);\r\n      }\r\n    }\r\n\r\n    this._themeClass = value;\r\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\r\n    if (this._containerElement && this._containerElement.parentNode) {\r\n      this._containerElement.parentNode.removeChild(this._containerElement);\r\n    }\r\n  }\n/**\n * This method returns the overlay container element.  It will lazily\rcreate the element the first time  it is called to facilitate using\rthe container in non-browser environments.\r\\@returns the container element\n * @return {?}\n */\ngetContainerElement(): HTMLElement {\r\n    if (!this._containerElement) { this._createContainer(); }\r\n    return this._containerElement;\r\n  }\n/**\n * Create the overlay container element, which is simply a div\rwith the 'cdk-overlay-container' class on the document body.\n * @return {?}\n */\nprotected _createContainer(): void {\r\n    let /** @type {?} */ container = document.createElement('div');\r\n    container.classList.add('cdk-overlay-container');\r\n\r\n    if (this._themeClass) {\r\n      container.classList.add(this._themeClass);\r\n    }\r\n\r\n    document.body.appendChild(container);\r\n    this._containerElement = container;\r\n  }\r\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction OverlayContainer_tsickle_Closure_declarations() {\n/** @type {?} */\nOverlayContainer.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nOverlayContainer.ctorParameters;\n/** @type {?} */\nOverlayContainer.prototype._containerElement;\n/** @type {?} */\nOverlayContainer.prototype._themeClass;\n}\n\n/**\n * \\@docs-private\n * @param {?} parentContainer\n * @return {?}\n */\nexport function OVERLAY_CONTAINER_PROVIDER_FACTORY(parentContainer: OverlayContainer) {\r\n  return parentContainer || new OverlayContainer();\r\n}\n/**\n * \\@docs-private\n */\nexport const OVERLAY_CONTAINER_PROVIDER = {\r\n  // If there is already an OverlayContainer available, use that. Otherwise, provide a new one.\r\n  provide: OverlayContainer,\r\n  deps: [[new Optional(), new SkipSelf(), OverlayContainer]],\r\n  useFactory: OVERLAY_CONTAINER_PROVIDER_FACTORY\r\n};\r\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {OverlayRef} from '../overlay-ref';\r\n\r\n/**\r\n * Describes a strategy that will be used by an overlay\r\n * to handle scroll events while it is open.\r\n */\r\nexport interface ScrollStrategy {\r\n  enable: () => void;\r\n  disable: () => void;\r\n  attach: (overlayRef: OverlayRef) => void;\r\n}\n/**\n * Returns an error to be thrown when attempting to attach an already-attached scroll strategy.\n * @return {?}\n */\nexport function getMdScrollStrategyAlreadyAttachedError(): Error {\r\n  return Error(`Scroll strategy has already been attached.`);\r\n}\r\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {ScrollStrategy} from './scroll-strategy';\r\nimport {ViewportRuler} from '@angular/cdk/scrolling';\n/**\n * Strategy that will prevent the user from scrolling while the overlay is visible.\n */\nexport class BlockScrollStrategy implements ScrollStrategy {\nprivate _previousHTMLStyles = { top: '', left: '' };\nprivate _previousScrollPosition: { top: number, left: number };\nprivate _isEnabled = false;\n/**\n * @param {?} _viewportRuler\n */\nconstructor(private _viewportRuler: ViewportRuler) { }\n/**\n * @return {?}\n */\nattach() { }\n/**\n * @return {?}\n */\nenable() {\r\n    if (this._canBeEnabled()) {\r\n      const /** @type {?} */ root = document.documentElement;\r\n\r\n      this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();\r\n\r\n      // Cache the previous inline styles in case the user had set them.\r\n      this._previousHTMLStyles.left = root.style.left || '';\r\n      this._previousHTMLStyles.top = root.style.top || '';\r\n\r\n      // Note: we're using the `html` node, instead of the `body`, because the `body` may\r\n      // have the user agent margin, whereas the `html` is guaranteed not to have one.\r\n      root.style.left = `${-this._previousScrollPosition.left}px`;\r\n      root.style.top = `${-this._previousScrollPosition.top}px`;\r\n      root.classList.add('cdk-global-scrollblock');\r\n      this._isEnabled = true;\r\n    }\r\n  }\n/**\n * @return {?}\n */\ndisable() {\r\n    if (this._isEnabled) {\r\n      this._isEnabled = false;\r\n      document.documentElement.style.left = this._previousHTMLStyles.left;\r\n      document.documentElement.style.top = this._previousHTMLStyles.top;\r\n      document.documentElement.classList.remove('cdk-global-scrollblock');\r\n      window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);\r\n    }\r\n  }\n/**\n * @return {?}\n */\nprivate _canBeEnabled(): boolean {\r\n    // Since the scroll strategies can't be singletons, we have to use a global CSS class\r\n    // (`cdk-global-scrollblock`) to make sure that we don't try to disable global\r\n    // scrolling multiple times.\r\n    if (document.documentElement.classList.contains('cdk-global-scrollblock') || this._isEnabled) {\r\n      return false;\r\n    }\r\n\r\n    const /** @type {?} */ body = document.body;\r\n    const /** @type {?} */ viewport = this._viewportRuler.getViewportRect();\r\n    return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;\r\n  }\r\n}\n\nfunction BlockScrollStrategy_tsickle_Closure_declarations() {\n/** @type {?} */\nBlockScrollStrategy.prototype._previousHTMLStyles;\n/** @type {?} */\nBlockScrollStrategy.prototype._previousScrollPosition;\n/** @type {?} */\nBlockScrollStrategy.prototype._isEnabled;\n/** @type {?} */\nBlockScrollStrategy.prototype._viewportRuler;\n}\n\r\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {Subscription} from 'rxjs/Subscription';\r\nimport {ScrollStrategy, getMdScrollStrategyAlreadyAttachedError} from './scroll-strategy';\r\nimport {OverlayRef} from '../overlay-ref';\r\nimport {ScrollDispatcher} from '@angular/cdk/scrolling';\r\n\r\n/**\r\n * Config options for the RepositionScrollStrategy.\r\n */\r\nexport interface RepositionScrollStrategyConfig {\r\n  scrollThrottle?: number;\r\n}\n/**\n * Strategy that will update the element position as the user is scrolling.\n */\nexport class RepositionScrollStrategy implements ScrollStrategy {\nprivate _scrollSubscription: Subscription|null = null;\nprivate _overlayRef: OverlayRef;\n/**\n * @param {?} _scrollDispatcher\n * @param {?=} _config\n */\nconstructor(\nprivate _scrollDispatcher: ScrollDispatcher,\nprivate _config?: RepositionScrollStrategyConfig) { }\n/**\n * @param {?} overlayRef\n * @return {?}\n */\nattach(overlayRef: OverlayRef) {\r\n    if (this._overlayRef) {\r\n      throw getMdScrollStrategyAlreadyAttachedError();\r\n    }\r\n\r\n    this._overlayRef = overlayRef;\r\n  }\n/**\n * @return {?}\n */\nenable() {\r\n    if (!this._scrollSubscription) {\r\n      let /** @type {?} */ throttle = this._config ? this._config.scrollThrottle : 0;\r\n\r\n      this._scrollSubscription = this._scrollDispatcher.scrolled(throttle, () => {\r\n        this._overlayRef.updatePosition();\r\n      });\r\n    }\r\n  }\n/**\n * @return {?}\n */\ndisable() {\r\n    if (this._scrollSubscription) {\r\n      this._scrollSubscription.unsubscribe();\r\n      this._scrollSubscription = null;\r\n    }\r\n  }\r\n}\n\nfunction RepositionScrollStrategy_tsickle_Closure_declarations() {\n/** @type {?} */\nRepositionScrollStrategy.prototype._scrollSubscription;\n/** @type {?} */\nRepositionScrollStrategy.prototype._overlayRef;\n/** @type {?} */\nRepositionScrollStrategy.prototype._scrollDispatcher;\n/** @type {?} */\nRepositionScrollStrategy.prototype._config;\n}\n\r\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {Injectable} from '@angular/core';\r\nimport {CloseScrollStrategy} from './close-scroll-strategy';\r\nimport {NoopScrollStrategy} from './noop-scroll-strategy';\r\nimport {BlockScrollStrategy} from './block-scroll-strategy';\r\nimport {ScrollDispatcher} from '@angular/cdk/scrolling';\r\nimport {ViewportRuler} from '@angular/cdk/scrolling';\r\nimport {\r\n  RepositionScrollStrategy,\r\n  RepositionScrollStrategyConfig,\r\n} from './reposition-scroll-strategy';\n/**\n * Options for how an overlay will handle scrolling.\r\rUsers can provide a custom value for `ScrollStrategyOptions` to replace the default\rbehaviors. This class primarily acts as a factory for ScrollStrategy instances.\n */\nexport class ScrollStrategyOptions {\n/**\n * @param {?} _scrollDispatcher\n * @param {?} _viewportRuler\n */\nconstructor(\nprivate _scrollDispatcher: ScrollDispatcher,\nprivate _viewportRuler: ViewportRuler) { }\n/**\n * Do nothing on scroll.\n */\nnoop = () => new NoopScrollStrategy();\n/**\n * Close the overlay as soon as the user scrolls.\n */\nclose = () => new CloseScrollStrategy(this._scrollDispatcher);\n/**\n * Block scrolling.\n */\nblock = () => new BlockScrollStrategy(this._viewportRuler);\n/**\n * Update the overlay's position on scroll.\r\\@param config Configuration to be used inside the scroll strategy.\rAllows debouncing the reposition calls.\n */\nreposition = (config?: RepositionScrollStrategyConfig) =>\r\n      new RepositionScrollStrategy(this._scrollDispatcher, config)\r\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ScrollDispatcher, },\n{type: ViewportRuler, },\n];\n}\n\nfunction ScrollStrategyOptions_tsickle_Closure_declarations() {\n/** @type {?} */\nScrollStrategyOptions.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nScrollStrategyOptions.ctorParameters;\n/**\n * Do nothing on scroll.\n * @type {?}\n */\nScrollStrategyOptions.prototype.noop;\n/**\n * Close the overlay as soon as the user scrolls.\n * @type {?}\n */\nScrollStrategyOptions.prototype.close;\n/**\n * Block scrolling.\n * @type {?}\n */\nScrollStrategyOptions.prototype.block;\n/**\n * Update the overlay's position on scroll.\r\\@param config Configuration to be used inside the scroll strategy.\rAllows debouncing the reposition calls.\n * @type {?}\n */\nScrollStrategyOptions.prototype.reposition;\n/** @type {?} */\nScrollStrategyOptions.prototype._scrollDispatcher;\n/** @type {?} */\nScrollStrategyOptions.prototype._viewportRuler;\n}\n\r\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {\r\n  ComponentFactoryResolver,\r\n  Injectable,\r\n  ApplicationRef,\r\n  Injector,\r\n  NgZone,\r\n} from '@angular/core';\r\nimport {DomPortalHost} from '@angular/cdk/portal';\r\nimport {OverlayState} from './overlay-state';\r\nimport {OverlayRef} from './overlay-ref';\r\nimport {OverlayPositionBuilder} from './position/overlay-position-builder';\r\nimport {OverlayContainer} from './overlay-container';\r\nimport {ScrollStrategyOptions} from './scroll/index';\n/**\n * Next overlay unique ID.\n */\nlet nextUniqueId = 0;\n/**\n * The default state for newly created overlays.\n */\nlet defaultState = new OverlayState();\n/**\n * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be\rused as a low-level building building block for other components. Dialogs, tooltips, menus,\rselects, etc. can all be built using overlays. The service should primarily be used by authors\rof re-usable components rather than developers building end-user applications.\r\rAn overlay *is* a PortalHost, so any kind of Portal can be loaded into one.\n */\nexport class Overlay {\n/**\n * @param {?} scrollStrategies\n * @param {?} _overlayContainer\n * @param {?} _componentFactoryResolver\n * @param {?} _positionBuilder\n * @param {?} _appRef\n * @param {?} _injector\n * @param {?} _ngZone\n */\nconstructor(public scrollStrategies: ScrollStrategyOptions,\nprivate _overlayContainer: OverlayContainer,\nprivate _componentFactoryResolver: ComponentFactoryResolver,\nprivate _positionBuilder: OverlayPositionBuilder,\nprivate _appRef: ApplicationRef,\nprivate _injector: Injector,\nprivate _ngZone: NgZone) { }\n/**\n * Creates an overlay.\r\\@param state State to apply to the overlay.\r\\@returns Reference to the created overlay.\n * @param {?=} state\n * @return {?}\n */\ncreate(state: OverlayState = defaultState): OverlayRef {\r\n    const /** @type {?} */ pane = this._createPaneElement();\r\n    const /** @type {?} */ portalHost = this._createPortalHost(pane);\r\n    return new OverlayRef(portalHost, pane, state, this._ngZone);\r\n  }\n/**\n * Returns a position builder that can be used, via fluent API,\rto construct and configure a position strategy.\n * @return {?}\n */\nposition(): OverlayPositionBuilder {\r\n    return this._positionBuilder;\r\n  }\n/**\n * Creates the DOM element for an overlay and appends it to the overlay container.\r\\@returns Newly-created pane element\n * @return {?}\n */\nprivate _createPaneElement(): HTMLElement {\r\n    let /** @type {?} */ pane = document.createElement('div');\r\n\r\n    pane.id = `cdk-overlay-${nextUniqueId++}`;\r\n    pane.classList.add('cdk-overlay-pane');\r\n    this._overlayContainer.getContainerElement().appendChild(pane);\r\n\r\n    return pane;\r\n  }\n/**\n * Create a DomPortalHost into which the overlay content can be loaded.\r\\@param pane The DOM element to turn into a portal host.\r\\@returns A portal host for the given DOM element.\n * @param {?} pane\n * @return {?}\n */\nprivate _createPortalHost(pane: HTMLElement): DomPortalHost {\r\n    return new DomPortalHost(pane, this._componentFactoryResolver, this._appRef, this._injector);\r\n  }\r\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ScrollStrategyOptions, },\n{type: OverlayContainer, },\n{type: ComponentFactoryResolver, },\n{type: OverlayPositionBuilder, },\n{type: ApplicationRef, },\n{type: Injector, },\n{type: NgZone, },\n];\n}\n\nfunction Overlay_tsickle_Closure_declarations() {\n/** @type {?} */\nOverlay.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nOverlay.ctorParameters;\n/** @type {?} */\nOverlay.prototype.scrollStrategies;\n/** @type {?} */\nOverlay.prototype._overlayContainer;\n/** @type {?} */\nOverlay.prototype._componentFactoryResolver;\n/** @type {?} */\nOverlay.prototype._positionBuilder;\n/** @type {?} */\nOverlay.prototype._appRef;\n/** @type {?} */\nOverlay.prototype._injector;\n/** @type {?} */\nOverlay.prototype._ngZone;\n}\n\r\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\nimport {NgModule, Provider} from '@angular/core';\r\nimport {PortalModule} from '@angular/cdk/portal';\r\nimport {Overlay} from './overlay';\r\nimport {ScrollDispatchModule, VIEWPORT_RULER_PROVIDER} from '@angular/cdk/scrolling';\r\nimport {\r\n  ConnectedOverlayDirective,\r\n  MD_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER,\r\n  OverlayOrigin,\r\n} from './overlay-directives';\r\nimport {OverlayPositionBuilder} from './position/overlay-position-builder';\r\nimport {OVERLAY_CONTAINER_PROVIDER} from './overlay-container';\r\nimport {ScrollStrategyOptions} from './scroll/scroll-strategy-options';\r\n\r\n\r\nexport const /** @type {?} */ OVERLAY_PROVIDERS: Provider[] = [\r\n  Overlay,\r\n  OverlayPositionBuilder,\r\n  VIEWPORT_RULER_PROVIDER,\r\n  OVERLAY_CONTAINER_PROVIDER,\r\n  MD_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER,\r\n];\nexport class OverlayModule {static decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{\r\n  imports: [PortalModule, ScrollDispatchModule],\r\n  exports: [ConnectedOverlayDirective, OverlayOrigin, ScrollDispatchModule],\r\n  declarations: [ConnectedOverlayDirective, OverlayOrigin],\r\n  providers: [OVERLAY_PROVIDERS, ScrollStrategyOptions],\r\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction OverlayModule_tsickle_Closure_declarations() {\n/** @type {?} */\nOverlayModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nOverlayModule.ctorParameters;\n}\n\r\n\r\n\r\nexport {Overlay} from './overlay';\r\nexport {OverlayContainer} from './overlay-container';\r\nexport {FullscreenOverlayContainer} from './fullscreen-overlay-container';\r\nexport {OverlayRef} from './overlay-ref';\r\nexport {OverlayState} from './overlay-state';\r\nexport {ConnectedOverlayDirective, OverlayOrigin} from './overlay-directives';\r\nexport {ViewportRuler} from '@angular/cdk/scrolling';\r\nexport {ComponentType} from '@angular/cdk/portal';\r\n\r\nexport {HorizontalConnectionPos,VerticalConnectionPos,OriginConnectionPosition,OverlayConnectionPosition,ConnectionPositionPair,ScrollingVisibility,ConnectedOverlayPositionChange} from './position/connected-position';\r\nexport {Scrollable,ScrollDispatcher,ScrollStrategy,ScrollStrategyOptions,RepositionScrollStrategy,CloseScrollStrategy,NoopScrollStrategy,BlockScrollStrategy} from './scroll/index';\r\n\r\n// Export pre-defined position strategies and interface to build custom ones.\r\nexport {PositionStrategy} from './position/position-strategy';\r\nexport {GlobalPositionStrategy} from './position/global-position-strategy';\r\nexport {ConnectedPositionStrategy} from './position/connected-position-strategy';\r\nexport {VIEWPORT_RULER_PROVIDER} from '@angular/cdk/scrolling';\r\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {Injectable} from '@angular/core';\r\nimport {OverlayContainer} from './overlay-container';\n/**\n * The FullscreenOverlayContainer is the alternative to OverlayContainer\rthat supports correct displaying of overlay elements in Fullscreen mode\rhttps://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen\rIt should be provided in the root component that way:\rproviders: [\r  {provide: OverlayContainer, useClass: FullscreenOverlayContainer}\r],\n */\nexport class FullscreenOverlayContainer extends OverlayContainer {\n/**\n * @return {?}\n */\nprotected _createContainer(): void {\r\n    super._createContainer();\r\n    this._adjustParentForFullscreenChange();\r\n    this._addFullscreenChangeListener(() => this._adjustParentForFullscreenChange());\r\n  }\n/**\n * @return {?}\n */\nprivate _adjustParentForFullscreenChange(): void {\r\n    if (!this._containerElement) {\r\n      return;\r\n    }\r\n    let /** @type {?} */ fullscreenElement = this.getFullscreenElement();\r\n    let /** @type {?} */ parent = fullscreenElement || document.body;\r\n    parent.appendChild(this._containerElement);\r\n  }\n/**\n * @param {?} fn\n * @return {?}\n */\nprivate _addFullscreenChangeListener(fn: () => void) {\r\n    if (document.fullscreenEnabled) {\r\n      document.addEventListener('fullscreenchange', fn);\r\n    } else if (document.webkitFullscreenEnabled) {\r\n      document.addEventListener('webkitfullscreenchange', fn);\r\n    } else if (( /** @type {?} */((document as any))).mozFullScreenEnabled) {\r\n      document.addEventListener('mozfullscreenchange', fn);\r\n    } else if (( /** @type {?} */((document as any))).msFullscreenEnabled) {\r\n      document.addEventListener('MSFullscreenChange', fn);\r\n    }\r\n  }\n/**\n * When the page is put into fullscreen mode, a specific element is specified.\rOnly that element and its children are visible when in fullscreen mode.\n * @return {?}\n */\ngetFullscreenElement(): Element {\r\n    return document.fullscreenElement ||\r\n        document.webkitFullscreenElement ||\r\n        ( /** @type {?} */((document as any))).mozFullScreenElement ||\r\n        ( /** @type {?} */((document as any))).msFullscreenElement ||\r\n        null;\r\n  }\r\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction FullscreenOverlayContainer_tsickle_Closure_declarations() {\n/** @type {?} */\nFullscreenOverlayContainer.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nFullscreenOverlayContainer.ctorParameters;\n}\n\r\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport {OVERLAY_PROVIDERS,OverlayModule,Overlay,OverlayContainer,FullscreenOverlayContainer,OverlayRef,OverlayState,ConnectedOverlayDirective,OverlayOrigin,ViewportRuler,ComponentType,PositionStrategy,GlobalPositionStrategy,ConnectedPositionStrategy,VIEWPORT_RULER_PROVIDER,HorizontalConnectionPos,VerticalConnectionPos,OriginConnectionPosition,OverlayConnectionPosition,ConnectionPositionPair,ScrollingVisibility,ConnectedOverlayPositionChange,Scrollable,ScrollDispatcher,ScrollStrategy,ScrollStrategyOptions,RepositionScrollStrategy,CloseScrollStrategy,NoopScrollStrategy,BlockScrollStrategy} from './public_api';\n\nexport {OVERLAY_CONTAINER_PROVIDER as b,OVERLAY_CONTAINER_PROVIDER_FACTORY as a} from './overlay-container';\nexport {MD_CONNECTED_OVERLAY_SCROLL_STRATEGY as c,MD_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER as e,MD_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY as d} from './overlay-directives';\nexport {OverlayPositionBuilder as f} from './position/overlay-position-builder';"],"names":["__extends","d","b","__","this","constructor","extendStatics","prototype","Object","create","outsideRight","element","left","containerBounds","right","outsideAbove","outsideBelow","outsideLeft","clippedBelow","bottom","scrollContainerRect","OVERLAY_CONTAINER_PROVIDER_FACTORY","parentContainer","OverlayContainer","getMdScrollStrategyAlreadyAttachedError","Error","MD_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY","overlay","scrollStrategies","reposition","setPrototypeOf","__proto__","Array","p","hasOwnProperty","NoopScrollStrategy","direction","state","keys","forEach","key","_this","OverlayRef","_portalHost","_pane","_state","_ngZone","_backdropElement","_backdropClick","Subject","_attachments","_detachments","scrollStrategy","attach","portal","attachResult","positionStrategy","_updateStackingOrder","updateSize","updateDirection","updatePosition","_togglePointerEvents","hasBackdrop","_attachBackdrop","panelClass","isArray","cls","classList","add","next","detach","detachBackdrop","detachmentResult","dispose","disable","complete","hasAttached","backdropClick","asObservable","attachments","detachments","getState","apply","setAttribute","width","style","formatCssUnit","height","minWidth","minHeight","maxHeight","enablePointer","pointerEvents","backdropClass","insertBefore","nextSibling","appendChild","backdropToDetach","finishDetach_1","parentNode","removeChild","remove","addEventListener","runOutsideAngular","setTimeout","ConnectionPositionPair","ScrollingVisibility","ConnectedOverlayPositionChange","ctorParameters","type","decorators","Optional","_viewportRuler","_offsetX","scrollables","withFallbackPosition","originPos","overlayPos","defineProperty","ConnectedPositionStrategy","get","_dir","configurable","_overlayRef","overlayRef","overlayElement","originRect","_origin","getBoundingClientRect","viewportRect","getViewportRect","originPoint","_getOriginConnectionPoint","pos","overlayPoint","_getOverlayPoint","overlayRect","fitsInViewport","_setElementPosition","_lastConnectedPosition","lastPosition","_preferredPositions","_getStartX","rect","_isRtl","_getEndX","x","originX","originStartX","originEndX","y","originY","top","overlayStartX","overlayX","overlayY","overlayStartY","_offsetY","leftOverflow","rightOverflow","topOverflow","_getScrollVisibility","originBounds","isOriginOutsideView","isElementScrolledOutsideView","scrollContainerBounds","isOverlayClipped","isElementClippedByScrolling","overlayBounds","isOverlayOutsideView","verticalStyleProperty","document","documentElement","clientHeight","horizontalStyleProperty","scrollableViewProperties","positionChange","_onPositionChange","overflows","reduce","currentValue","currentOverflow","Math","max","GlobalPositionStrategy","_justifyContent","_width","_height","_wrapper","value","_leftOffset","centerHorizontally","offset","centerVertically","_alignItems","createElement","styles","parentStyles","position","_cssPosition","OverlayPositionBuilder","connectedTo","elementRef","Injectable","set","_containerElement","_themeClass","getContainerElement","_createContainer","container","body","OVERLAY_CONTAINER_PROVIDER","provide","deps","SkipSelf","_scrollSubscription","CloseScrollStrategy","enable","_scrollDispatcher","scrolled","unsubscribe","_previousHTMLStyles","_isEnabled","BlockScrollStrategy","root","_previousScrollPosition","_canBeEnabled","viewport","scrollHeight","scrollWidth","RepositionScrollStrategy","block","config","ScrollStrategyOptions","ScrollDispatcher","ViewportRuler","defaultState","OverlayState","Overlay","_overlayContainer","_componentFactoryResolver","_positionBuilder","_injector","pane","_createPaneElement","portalHost","_createPortalHost","ComponentFactoryResolver","ApplicationRef","Injector","defaultPositionList","MD_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER","MD_CONNECTED_OVERLAY_SCROLL_STRATEGY","useFactory","OverlayOrigin","selector","ElementRef","ConnectedOverlayDirective","_overlay","_renderer","templateRef","viewContainerRef","_scrollStrategy","open","offsetX","enumerable","_position","positions","_positions","_minHeight","_backdropClass","_open","_hasBackdrop","ngOnDestroy","_destroyOverlay","_attachOverlay","_detachOverlay","length","_buildConfig","_createPositionStrategy","overlayConfig","strategy","origin","withOffsetX","withOffsetY","offsetY","_handlePositionChanges","_positionSubscription","withDirection","dir","_initEscapeListener","_templatePortal","emit","_backdropSubscription","_escapeListener","Directive","args","exportAs","Renderer2","TemplateRef","Input"],"mappings":"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"}