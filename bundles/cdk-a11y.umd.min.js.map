{"version":3,"file":"cdk-a11y.umd.min.js","sources":["../../node_modules/tslib/tslib.es6.js","../../src/cdk/a11y/interactivity-checker.ts","../../src/cdk/a11y/aria-reference.ts","../../src/cdk/a11y/aria-describer.ts","../../src/cdk/a11y/focus-trap.ts","../../src/cdk/a11y/live-announcer.ts","../../src/cdk/a11y/focus-monitor.ts","../../src/cdk/a11y/list-key-manager.ts","../../src/cdk/a11y/activedescendant-key-manager.ts","../../src/cdk/a11y/fake-mousedown.ts","../../src/cdk/a11y/focus-key-manager.ts","../../src/cdk/a11y/public_api.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {Injectable} from '@angular/core';\r\nimport {Platform} from '@angular/cdk/platform';\n/**\n * Utility for checking the interactivity of an element, such as whether is is focusable or\rtabbable.\n */\nexport class InteractivityChecker {\n/**\n * @param {?} _platform\n */\nconstructor(private _platform: Platform) {}\n/**\n * Gets whether an element is disabled.\r\r\\@param element Element to be checked.\r\\@returns Whether the element is disabled.\n * @param {?} element\n * @return {?}\n */\nisDisabled(element: HTMLElement): boolean {\r\n    // This does not capture some cases, such as a non-form control with a disabled attribute or\r\n    // a form control inside of a disabled form, but should capture the most common cases.\r\n    return element.hasAttribute('disabled');\r\n  }\n/**\n * Gets whether an element is visible for the purposes of interactivity.\r\rThis will capture states like `display: none` and `visibility: hidden`, but not things like\rbeing clipped by an `overflow: hidden` parent or being outside the viewport.\r\r\\@returns Whether the element is visible.\n * @param {?} element\n * @return {?}\n */\nisVisible(element: HTMLElement): boolean {\r\n    return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';\r\n  }\n/**\n * Gets whether an element can be reached via Tab key.\rAssumes that the element has already been checked with isFocusable.\r\r\\@param element Element to be checked.\r\\@returns Whether the element is tabbable.\n * @param {?} element\n * @return {?}\n */\nisTabbable(element: HTMLElement): boolean {\r\n    // Nothing is tabbable on the the server 😎\r\n    if (!this._platform.isBrowser) {\r\n      return false;\r\n    }\r\n\r\n    let /** @type {?} */ frameElement = /** @type {?} */(( getWindow(element).frameElement as HTMLElement));\r\n\r\n    if (frameElement) {\r\n\r\n      let /** @type {?} */ frameType = frameElement && frameElement.nodeName.toLowerCase();\r\n\r\n      // Frame elements inherit their tabindex onto all child elements.\r\n      if (getTabIndexValue(frameElement) === -1) {\r\n        return false;\r\n      }\r\n\r\n      // Webkit and Blink consider anything inside of an <object> element as non-tabbable.\r\n      if ((this._platform.BLINK || this._platform.WEBKIT) && frameType === 'object') {\r\n        return false;\r\n      }\r\n\r\n      // Webkit and Blink disable tabbing to an element inside of an invisible frame.\r\n      if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(frameElement)) {\r\n        return false;\r\n      }\r\n\r\n    }\r\n\r\n    let /** @type {?} */ nodeName = element.nodeName.toLowerCase();\r\n    let /** @type {?} */ tabIndexValue = getTabIndexValue(element);\r\n\r\n    if (element.hasAttribute('contenteditable')) {\r\n      return tabIndexValue !== -1;\r\n    }\r\n\r\n    if (nodeName === 'iframe') {\r\n      // The frames may be tabbable depending on content, but it's not possibly to reliably\r\n      // investigate the content of the frames.\r\n      return false;\r\n    }\r\n\r\n    if (nodeName === 'audio') {\r\n      if (!element.hasAttribute('controls')) {\r\n        // By default an <audio> element without the controls enabled is not tabbable.\r\n        return false;\r\n      } else if (this._platform.BLINK) {\r\n        // In Blink <audio controls> elements are always tabbable.\r\n        return true;\r\n      }\r\n    }\r\n\r\n    if (nodeName === 'video') {\r\n      if (!element.hasAttribute('controls') && this._platform.TRIDENT) {\r\n        // In Trident a <video> element without the controls enabled is not tabbable.\r\n        return false;\r\n      } else if (this._platform.BLINK || this._platform.FIREFOX) {\r\n        // In Chrome and Firefox <video controls> elements are always tabbable.\r\n        return true;\r\n      }\r\n    }\r\n\r\n    if (nodeName === 'object' && (this._platform.BLINK || this._platform.WEBKIT)) {\r\n      // In all Blink and WebKit based browsers <object> elements are never tabbable.\r\n      return false;\r\n    }\r\n\r\n    // In iOS the browser only considers some specific elements as tabbable.\r\n    if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {\r\n      return false;\r\n    }\r\n\r\n    return element.tabIndex >= 0;\r\n  }\n/**\n * Gets whether an element can be focused by the user.\r\r\\@param element Element to be checked.\r\\@returns Whether the element is focusable.\n * @param {?} element\n * @return {?}\n */\nisFocusable(element: HTMLElement): boolean {\r\n    // Perform checks in order of left to most expensive.\r\n    // Again, naive approach that does not capture many edge cases and browser quirks.\r\n    return isPotentiallyFocusable(element) && !this.isDisabled(element) && this.isVisible(element);\r\n  }\r\n\r\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: Platform, },\n];\n}\n\nfunction InteractivityChecker_tsickle_Closure_declarations() {\n/** @type {?} */\nInteractivityChecker.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nInteractivityChecker.ctorParameters;\n/** @type {?} */\nInteractivityChecker.prototype._platform;\n}\n\n/**\n * Checks whether the specified element has any geometry / rectangles.\n * @param {?} element\n * @return {?}\n */\nfunction hasGeometry(element: HTMLElement): boolean {\r\n  // Use logic from jQuery to check for an invisible element.\r\n  // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12\r\n  return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);\r\n}\n/**\n * Gets whether an element's\n * @param {?} element\n * @return {?}\n */\nfunction isNativeFormElement(element: Node) {\r\n  let /** @type {?} */ nodeName = element.nodeName.toLowerCase();\r\n  return nodeName === 'input' ||\r\n      nodeName === 'select' ||\r\n      nodeName === 'button' ||\r\n      nodeName === 'textarea';\r\n}\n/**\n * Gets whether an element is an <input type=\"hidden\">.\n * @param {?} element\n * @return {?}\n */\nfunction isHiddenInput(element: HTMLElement): boolean {\r\n  return isInputElement(element) && element.type == 'hidden';\r\n}\n/**\n * Gets whether an element is an anchor that has an href attribute.\n * @param {?} element\n * @return {?}\n */\nfunction isAnchorWithHref(element: HTMLElement): boolean {\r\n  return isAnchorElement(element) && element.hasAttribute('href');\r\n}\n/**\n * Gets whether an element is an input element.\n * @param {?} element\n * @return {?}\n */\nfunction isInputElement(element: HTMLElement): element is HTMLInputElement {\r\n  return element.nodeName.toLowerCase() == 'input';\r\n}\n/**\n * Gets whether an element is an anchor element.\n * @param {?} element\n * @return {?}\n */\nfunction isAnchorElement(element: HTMLElement): element is HTMLAnchorElement {\r\n  return element.nodeName.toLowerCase() == 'a';\r\n}\n/**\n * Gets whether an element has a valid tabindex.\n * @param {?} element\n * @return {?}\n */\nfunction hasValidTabIndex(element: HTMLElement): boolean {\r\n  if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {\r\n    return false;\r\n  }\r\n\r\n  let /** @type {?} */ tabIndex = element.getAttribute('tabindex');\r\n\r\n  // IE11 parses tabindex=\"\" as the value \"-32768\"\r\n  if (tabIndex == '-32768') {\r\n    return false;\r\n  }\r\n\r\n  return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));\r\n}\n/**\n * Returns the parsed tabindex from the element attributes instead of returning the\revaluated tabindex from the browsers defaults.\n * @param {?} element\n * @return {?}\n */\nfunction getTabIndexValue(element: HTMLElement): number | null {\r\n  if (!hasValidTabIndex(element)) {\r\n    return null;\r\n  }\r\n\r\n  // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\r\n  const /** @type {?} */ tabIndex = parseInt(element.getAttribute('tabindex') || '', 10);\r\n\r\n  return isNaN(tabIndex) ? -1 : tabIndex;\r\n}\n/**\n * Checks whether the specified element is potentially tabbable on iOS\n * @param {?} element\n * @return {?}\n */\nfunction isPotentiallyTabbableIOS(element: HTMLElement): boolean {\r\n  let /** @type {?} */ nodeName = element.nodeName.toLowerCase();\r\n  let /** @type {?} */ inputType = nodeName === 'input' && ( /** @type {?} */((element as HTMLInputElement))).type;\r\n\r\n  return inputType === 'text'\r\n      || inputType === 'password'\r\n      || nodeName === 'select'\r\n      || nodeName === 'textarea';\r\n}\n/**\n * Gets whether an element is potentially focusable without taking current visible/disabled state\rinto account.\n * @param {?} element\n * @return {?}\n */\nfunction isPotentiallyFocusable(element: HTMLElement): boolean {\r\n  // Inputs are potentially focusable *unless* they're type=\"hidden\".\r\n  if (isHiddenInput(element)) {\r\n    return false;\r\n  }\r\n\r\n  return isNativeFormElement(element) ||\r\n      isAnchorWithHref(element) ||\r\n      element.hasAttribute('contenteditable') ||\r\n      hasValidTabIndex(element);\r\n}\n/**\n * Gets the parent window of a DOM node with regards of being inside of an iframe.\n * @param {?} node\n * @return {?}\n */\nfunction getWindow(node: HTMLElement): Window {\r\n  return node.ownerDocument.defaultView || window;\r\n}\r\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","\n/**\n * IDs are deliminated by an empty space, as per the spec.\n */\nconst ID_DELIMINATOR = ' ';\n/**\n * Adds the given ID to the specified ARIA attribute on an element.\rUsed for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @param {?} id\n * @return {?}\n */\nexport function addAriaReferencedId(el: Element, attr: string, id: string) {\r\n  const /** @type {?} */ ids = getAriaReferenceIds(el, attr);\r\n  if (ids.some(existingId => existingId.trim() == id.trim())) { return; }\r\n  ids.push(id.trim());\r\n\r\n  el.setAttribute(attr, ids.join(ID_DELIMINATOR));\r\n}\n/**\n * Removes the given ID from the specified ARIA attribute on an element.\rUsed for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @param {?} id\n * @return {?}\n */\nexport function removeAriaReferencedId(el: Element, attr: string, id: string) {\r\n  const /** @type {?} */ ids = getAriaReferenceIds(el, attr);\r\n  const /** @type {?} */ filteredIds = ids.filter(val => val != id.trim());\r\n\r\n  el.setAttribute(attr, filteredIds.join(ID_DELIMINATOR));\r\n}\n/**\n * Gets the list of IDs referenced by the given ARIA attribute on an element.\rUsed for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @return {?}\n */\nexport function getAriaReferenceIds(el: Element, attr: string): string[] {\r\n  // Get string array of all individual ids (whitespace deliminated) in the attribute value\r\n  return (el.getAttribute(attr) || '').match(/\\S+/g) || [];\r\n}\r\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {Injectable, Optional, SkipSelf} from '@angular/core';\r\nimport {Platform} from '@angular/cdk/platform';\r\nimport {addAriaReferencedId, getAriaReferenceIds, removeAriaReferencedId} from './aria-reference';\r\n\r\n/**\r\n * Interface used to register message elements and keep a count of how many registrations have\r\n * the same message and the reference to the message element used for the aria-describedby.\r\n */\r\nexport interface RegisteredMessage {\r\n  messageElement: Element;\r\n  referenceCount: number;\r\n}\n/**\n * ID used for the body container where all messages are appended.\n */\nexport const MESSAGES_CONTAINER_ID = 'cdk-describedby-message-container';\n/**\n * ID prefix used for each created message element.\n */\nexport const CDK_DESCRIBEDBY_ID_PREFIX = 'cdk-describedby-message';\n/**\n * Attribute given to each host element that is described by a message element.\n */\nexport const CDK_DESCRIBEDBY_HOST_ATTRIBUTE = 'cdk-describedby-host';\n/**\n * Global incremental identifier for each registered message element.\n */\nlet nextId = 0;\n/**\n * Global map of all registered message elements that have been placed into the document.\n */\nconst messageRegistry = new Map<string, RegisteredMessage>();\n/**\n * Container for all registered messages.\n */\nlet messagesContainer: HTMLElement | null = null;\n/**\n * Utility that creates visually hidden elements with a message content. Useful for elements that\rwant to use aria-describedby to further describe themselves without adding additional visual\rcontent.\r\\@docs-private\n */\nexport class AriaDescriber {\n/**\n * @param {?} _platform\n */\nconstructor(private _platform: Platform) { }\n/**\n * Adds to the host element an aria-describedby reference to a hidden element that contains\rthe message. If the same message has already been registered, then it will reuse the created\rmessage element.\n * @param {?} hostElement\n * @param {?} message\n * @return {?}\n */\ndescribe(hostElement: Element, message: string) {\r\n    if (!this._platform.isBrowser || !message.trim()) { return; }\r\n\r\n    if (!messageRegistry.has(message)) {\r\n      createMessageElement(message);\r\n    }\r\n\r\n    if (!isElementDescribedByMessage(hostElement, message)) {\r\n      addMessageReference(hostElement, message);\r\n    }\r\n  }\n/**\n * Removes the host element's aria-describedby reference to the message element.\n * @param {?} hostElement\n * @param {?} message\n * @return {?}\n */\nremoveDescription(hostElement: Element, message: string) {\r\n    if (!this._platform.isBrowser || !message.trim()) {\r\n      return;\r\n    }\r\n\r\n    if (isElementDescribedByMessage(hostElement, message)) {\r\n      removeMessageReference(hostElement, message);\r\n    }\r\n\r\n    const /** @type {?} */ registeredMessage = messageRegistry.get(message);\r\n    if (registeredMessage && registeredMessage.referenceCount === 0) {\r\n      deleteMessageElement(message);\r\n    }\r\n\r\n    if (messagesContainer && messagesContainer.childNodes.length === 0) {\r\n      deleteMessagesContainer();\r\n    }\r\n  }\n/**\n * Unregisters all created message elements and removes the message container.\n * @return {?}\n */\nngOnDestroy() {\r\n    if (!this._platform.isBrowser) { return; }\r\n\r\n    const /** @type {?} */ describedElements = document.querySelectorAll(`[${CDK_DESCRIBEDBY_HOST_ATTRIBUTE}]`);\r\n    for (let /** @type {?} */ i = 0; i < describedElements.length; i++) {\r\n      removeCdkDescribedByReferenceIds(describedElements[i]);\r\n      describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\r\n    }\r\n\r\n    if (messagesContainer) {\r\n      deleteMessagesContainer();\r\n    }\r\n\r\n    messageRegistry.clear();\r\n  }\r\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: Platform, },\n];\n}\n\nfunction AriaDescriber_tsickle_Closure_declarations() {\n/** @type {?} */\nAriaDescriber.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nAriaDescriber.ctorParameters;\n/** @type {?} */\nAriaDescriber.prototype._platform;\n}\n\n/**\n * Creates a new element in the visually hidden message container element with the message\ras its content and adds it to the message registry.\n * @param {?} message\n * @return {?}\n */\nfunction createMessageElement(message: string) {\r\n  const /** @type {?} */ messageElement = document.createElement('div');\r\n  messageElement.setAttribute('id', `${CDK_DESCRIBEDBY_ID_PREFIX}-${nextId++}`);\r\n  messageElement.appendChild( /** @type {?} */((document.createTextNode(message))));\r\n\r\n  if (!messagesContainer) { createMessagesContainer(); } /** @type {?} */((\r\n  messagesContainer)).appendChild(messageElement);\r\n\r\n  messageRegistry.set(message, {messageElement, referenceCount: 0});\r\n}\n/**\n * Deletes the message element from the global messages container.\n * @param {?} message\n * @return {?}\n */\nfunction deleteMessageElement(message: string) {\r\n  const /** @type {?} */ registeredMessage = messageRegistry.get(message);\r\n  const /** @type {?} */ messageElement = registeredMessage && registeredMessage.messageElement;\r\n  if (messagesContainer && messageElement) {\r\n    messagesContainer.removeChild(messageElement);\r\n  }\r\n  messageRegistry.delete(message);\r\n}\n/**\n * Creates the global container for all aria-describedby messages.\n * @return {?}\n */\nfunction createMessagesContainer() {\r\n  messagesContainer = document.createElement('div');\r\n\r\n  messagesContainer.setAttribute('id', MESSAGES_CONTAINER_ID);\r\n  messagesContainer.setAttribute('aria-hidden', 'true');\r\n  messagesContainer.style.display = 'none';\r\n  document.body.appendChild(messagesContainer);\r\n}\n/**\n * Deletes the global messages container.\n * @return {?}\n */\nfunction deleteMessagesContainer() {\r\n  document.body.removeChild( /** @type {?} */((messagesContainer)));\r\n  messagesContainer = null;\r\n}\n/**\n * Removes all cdk-describedby messages that are hosted through the element.\n * @param {?} element\n * @return {?}\n */\nfunction removeCdkDescribedByReferenceIds(element: Element) {\r\n  // Remove all aria-describedby reference IDs that are prefixed by CDK_DESCRIBEDBY_ID_PREFIX\r\n  const /** @type {?} */ originalReferenceIds = getAriaReferenceIds(element, 'aria-describedby')\r\n      .filter(id => id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0);\r\n  element.setAttribute('aria-describedby', originalReferenceIds.join(' '));\r\n}\n/**\n * Adds a message reference to the element using aria-describedby and increments the registered\rmessage's reference count.\n * @param {?} element\n * @param {?} message\n * @return {?}\n */\nfunction addMessageReference(element: Element, message: string) {\r\n  const /** @type {?} */ registeredMessage = /** @type {?} */(( messageRegistry.get(message)));\r\n\r\n  // Add the aria-describedby reference and set the describedby_host attribute to mark the element.\r\n  addAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\r\n  element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, '');\r\n\r\n  registeredMessage.referenceCount++;\r\n}\n/**\n * Removes a message reference from the element using aria-describedby and decrements the registered\rmessage's reference count.\n * @param {?} element\n * @param {?} message\n * @return {?}\n */\nfunction removeMessageReference(element: Element, message: string) {\r\n  const /** @type {?} */ registeredMessage = /** @type {?} */(( messageRegistry.get(message)));\r\n  registeredMessage.referenceCount--;\r\n\r\n  removeAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\r\n  element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\r\n}\n/**\n * Returns true if the element has been described by the provided message ID.\n * @param {?} element\n * @param {?} message\n * @return {?}\n */\nfunction isElementDescribedByMessage(element: Element, message: string): boolean {\r\n  const /** @type {?} */ referenceIds = getAriaReferenceIds(element, 'aria-describedby');\r\n  const /** @type {?} */ registeredMessage = messageRegistry.get(message);\r\n  const /** @type {?} */ messageId = registeredMessage && registeredMessage.messageElement.id;\r\n\r\n  return !!messageId && referenceIds.indexOf(messageId) != -1;\r\n}\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} platform\n * @return {?}\n */\nexport function ARIA_DESCRIBER_PROVIDER_FACTORY(\r\n    parentDispatcher: AriaDescriber, platform: Platform) {\r\n  return parentDispatcher || new AriaDescriber(platform);\r\n}\n/**\n * \\@docs-private\n */\nexport const ARIA_DESCRIBER_PROVIDER = {\r\n  // If there is already an AriaDescriber available, use that. Otherwise, provide a new one.\r\n  provide: AriaDescriber,\r\n  deps: [\r\n    [new Optional(), new SkipSelf(), AriaDescriber],\r\n    Platform\r\n  ],\r\n  useFactory: ARIA_DESCRIBER_PROVIDER_FACTORY\r\n};\r\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {\r\n  Directive,\r\n  ElementRef,\r\n  Input,\r\n  NgZone,\r\n  OnDestroy,\r\n  AfterContentInit,\r\n  Injectable,\r\n} from '@angular/core';\r\nimport {coerceBooleanProperty} from '@angular/cdk/coercion';\r\nimport {Platform} from '@angular/cdk/platform';\r\nimport {first} from '@angular/cdk/rxjs';\r\nimport {InteractivityChecker} from './interactivity-checker';\n/**\n * Class that allows for trapping focus within a DOM element.\r\rNOTE: This class currently uses a very simple (naive) approach to focus trapping.\rIt assumes that the tab order is the same as DOM order, which is not necessarily true.\rThings like tabIndex > 0, flex `order`, and shadow roots can cause to two to misalign.\rThis will be replaced with a more intelligent solution before the library is considered stable.\n */\nexport class FocusTrap {\nprivate _startAnchor: HTMLElement | null;\nprivate _endAnchor: HTMLElement | null;\n/**\n * Whether the focus trap is active.\n * @return {?}\n */\nget enabled(): boolean { return this._enabled; }\n/**\n * @param {?} val\n * @return {?}\n */\nset enabled(val: boolean) {\r\n    this._enabled = val;\r\n\r\n    if (this._startAnchor && this._endAnchor) {\r\n      this._startAnchor.tabIndex = this._endAnchor.tabIndex = this._enabled ? 0 : -1;\r\n    }\r\n  }\nprivate _enabled: boolean = true;\n/**\n * @param {?} _element\n * @param {?} _platform\n * @param {?} _checker\n * @param {?} _ngZone\n * @param {?=} deferAnchors\n */\nconstructor(\nprivate _element: HTMLElement,\nprivate _platform: Platform,\nprivate _checker: InteractivityChecker,\nprivate _ngZone: NgZone,\r\n    deferAnchors = false) {\r\n\r\n    if (!deferAnchors) {\r\n      // this.attachAnchors();\r\n    }\r\n  }\n/**\n * Destroys the focus trap by cleaning up the anchors.\n * @return {?}\n */\ndestroy() {\r\n    if (this._startAnchor && this._startAnchor.parentNode) {\r\n      this._startAnchor.parentNode.removeChild(this._startAnchor);\r\n    }\r\n\r\n    if (this._endAnchor && this._endAnchor.parentNode) {\r\n      this._endAnchor.parentNode.removeChild(this._endAnchor);\r\n    }\r\n\r\n    this._startAnchor = this._endAnchor = null;\r\n  }\n/**\n * Inserts the anchors into the DOM. This is usually done automatically\rin the constructor, but can be deferred for cases like directives with `*ngIf`.\n * @return {?}\n */\nattachAnchors(): void {\r\n    // If we're not on the browser, there can be no focus to trap.\r\n    if (!this._platform.isBrowser) {\r\n      return;\r\n    }\r\n\r\n    if (!this._startAnchor) {\r\n      this._startAnchor = this._createAnchor();\r\n    }\r\n\r\n    if (!this._endAnchor) {\r\n      this._endAnchor = this._createAnchor();\r\n    }\r\n\r\n    this._ngZone.runOutsideAngular(() => { /** @type {?} */((\r\n      this._startAnchor)).addEventListener('focus', () => {\r\n        this.focusLastTabbableElement();\r\n      }); /** @type {?} */((\r\n\r\n      this._endAnchor)).addEventListener('focus', () => {\r\n        this.focusFirstTabbableElement();\r\n      });\r\n\r\n      if (this._element.parentNode) {\r\n        this._element.parentNode.insertBefore( /** @type {?} */((this._startAnchor)), this._element);\r\n        this._element.parentNode.insertBefore( /** @type {?} */((this._endAnchor)), this._element.nextSibling);\r\n      }\r\n    });\r\n  }\n/**\n * Waits for the zone to stabilize, then either focuses the first element that the\ruser specified, or the first tabbable element.\r\\@returns Returns a promise that resolves with a boolean, depending\ron whether focus was moved successfuly.\n * @return {?}\n */\nfocusInitialElementWhenReady(): Promise<boolean> {\r\n    return new Promise<boolean>(resolve => {\r\n      this._executeOnStable(() => resolve(this.focusInitialElement()));\r\n    });\r\n  }\n/**\n * Waits for the zone to stabilize, then focuses\rthe first tabbable element within the focus trap region.\r\\@returns Returns a promise that resolves with a boolean, depending\ron whether focus was moved successfuly.\n * @return {?}\n */\nfocusFirstTabbableElementWhenReady(): Promise<boolean> {\r\n    return new Promise<boolean>(resolve => {\r\n      this._executeOnStable(() => resolve(this.focusFirstTabbableElement()));\r\n    });\r\n  }\n/**\n * Waits for the zone to stabilize, then focuses\rthe last tabbable element within the focus trap region.\r\\@returns Returns a promise that resolves with a boolean, depending\ron whether focus was moved successfuly.\n * @return {?}\n */\nfocusLastTabbableElementWhenReady(): Promise<boolean> {\r\n    return new Promise<boolean>(resolve => {\r\n      this._executeOnStable(() => resolve(this.focusLastTabbableElement()));\r\n    });\r\n  }\n/**\n * Get the specified boundary element of the trapped region.\r\\@param bound The boundary to get (start or end of trapped region).\r\\@returns The boundary element.\n * @param {?} bound\n * @return {?}\n */\nprivate _getRegionBoundary(bound: 'start' | 'end'): HTMLElement | null {\r\n    // Contains the deprecated version of selector, for temporary backwards comparability.\r\n    let /** @type {?} */ markers = /** @type {?} */(( this._element.querySelectorAll(`[cdk-focus-region-${bound}], ` +\r\n                                                 `[cdk-focus-${bound}]`) as NodeListOf<HTMLElement>));\r\n\r\n    for (let /** @type {?} */ i = 0; i < markers.length; i++) {\r\n      if (markers[i].hasAttribute(`cdk-focus-${bound}`)) {\r\n        console.warn(`Found use of deprecated attribute 'cdk-focus-${bound}',` +\r\n                     ` use 'cdk-focus-region-${bound}' instead.`, markers[i]);\r\n      }\r\n    }\r\n\r\n    if (bound == 'start') {\r\n      return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);\r\n    }\r\n    return markers.length ?\r\n        markers[markers.length - 1] : this._getLastTabbableElement(this._element);\r\n  }\n/**\n * Focuses the element that should be focused when the focus trap is initialized.\r\\@returns Returns whether focus was moved successfuly.\n * @return {?}\n */\nfocusInitialElement(): boolean {\r\n    const /** @type {?} */ redirectToElement = /** @type {?} */(( this._element.querySelector('[cdk-focus-initial]') as HTMLElement));\r\n\r\n    if (redirectToElement) {\r\n      redirectToElement.focus();\r\n      return true;\r\n    }\r\n\r\n    return this.focusFirstTabbableElement();\r\n  }\n/**\n * Focuses the first tabbable element within the focus trap region.\r\\@returns Returns whether focus was moved successfuly.\n * @return {?}\n */\nfocusFirstTabbableElement(): boolean {\r\n    const /** @type {?} */ redirectToElement = this._getRegionBoundary('start');\r\n\r\n    if (redirectToElement) {\r\n      redirectToElement.focus();\r\n    }\r\n\r\n    return !!redirectToElement;\r\n  }\n/**\n * Focuses the last tabbable element within the focus trap region.\r\\@returns Returns whether focus was moved successfuly.\n * @return {?}\n */\nfocusLastTabbableElement(): boolean {\r\n    const /** @type {?} */ redirectToElement = this._getRegionBoundary('end');\r\n\r\n    if (redirectToElement) {\r\n      redirectToElement.focus();\r\n    }\r\n\r\n    return !!redirectToElement;\r\n  }\n/**\n * Get the first tabbable element from a DOM subtree (inclusive).\n * @param {?} root\n * @return {?}\n */\nprivate _getFirstTabbableElement(root: HTMLElement): HTMLElement | null {\r\n    if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\r\n      return root;\r\n    }\r\n\r\n    // Iterate in DOM order. Note that IE doesn't have `children` for SVG so we fall\r\n    // back to `childNodes` which includes text nodes, comments etc.\r\n    let /** @type {?} */ children = root.children || root.childNodes;\r\n\r\n    for (let /** @type {?} */ i = 0; i < children.length; i++) {\r\n      let /** @type {?} */ tabbableChild = children[i].nodeType === Node.ELEMENT_NODE ?\r\n        this._getFirstTabbableElement( /** @type {?} */((children[i] as HTMLElement))) :\r\n        null;\r\n\r\n      if (tabbableChild) {\r\n        return tabbableChild;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\n/**\n * Get the last tabbable element from a DOM subtree (inclusive).\n * @param {?} root\n * @return {?}\n */\nprivate _getLastTabbableElement(root: HTMLElement): HTMLElement | null {\r\n    if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\r\n      return root;\r\n    }\r\n\r\n    // Iterate in reverse DOM order.\r\n    let /** @type {?} */ children = root.children || root.childNodes;\r\n\r\n    for (let /** @type {?} */ i = children.length - 1; i >= 0; i--) {\r\n      let /** @type {?} */ tabbableChild = children[i].nodeType === Node.ELEMENT_NODE ?\r\n        this._getLastTabbableElement( /** @type {?} */((children[i] as HTMLElement))) :\r\n        null;\r\n\r\n      if (tabbableChild) {\r\n        return tabbableChild;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\n/**\n * Creates an anchor element.\n * @return {?}\n */\nprivate _createAnchor(): HTMLElement {\r\n    let /** @type {?} */ anchor = document.createElement('div');\r\n    anchor.tabIndex = this._enabled ? 0 : -1;\r\n    anchor.classList.add('cdk-visually-hidden');\r\n    anchor.classList.add('cdk-focus-trap-anchor');\r\n    return anchor;\r\n  }\n/**\n * Executes a function when the zone is stable.\n * @param {?} fn\n * @return {?}\n */\nprivate _executeOnStable(fn: () => any): void {\r\n    if (this._ngZone.isStable) {\r\n      fn();\r\n    } else {\r\n      first.call(this._ngZone.onStable.asObservable()).subscribe(fn);\r\n    }\r\n  }\r\n}\n\nfunction FocusTrap_tsickle_Closure_declarations() {\n/** @type {?} */\nFocusTrap.prototype._startAnchor;\n/** @type {?} */\nFocusTrap.prototype._endAnchor;\n/** @type {?} */\nFocusTrap.prototype._enabled;\n/** @type {?} */\nFocusTrap.prototype._element;\n/** @type {?} */\nFocusTrap.prototype._platform;\n/** @type {?} */\nFocusTrap.prototype._checker;\n/** @type {?} */\nFocusTrap.prototype._ngZone;\n}\n\n/**\n * Factory that allows easy instantiation of focus traps.\n */\nexport class FocusTrapFactory {\n/**\n * @param {?} _checker\n * @param {?} _platform\n * @param {?} _ngZone\n */\nconstructor(\nprivate _checker: InteractivityChecker,\nprivate _platform: Platform,\nprivate _ngZone: NgZone) { }\n/**\n * @param {?} element\n * @param {?=} deferAnchors\n * @return {?}\n */\ncreate(element: HTMLElement, deferAnchors = false): FocusTrap {\r\n    return new FocusTrap(element, this._platform, this._checker, this._ngZone, deferAnchors);\r\n  }\r\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: InteractivityChecker, },\n{type: Platform, },\n{type: NgZone, },\n];\n}\n\nfunction FocusTrapFactory_tsickle_Closure_declarations() {\n/** @type {?} */\nFocusTrapFactory.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nFocusTrapFactory.ctorParameters;\n/** @type {?} */\nFocusTrapFactory.prototype._checker;\n/** @type {?} */\nFocusTrapFactory.prototype._platform;\n/** @type {?} */\nFocusTrapFactory.prototype._ngZone;\n}\n\n/**\n * Directive for trapping focus within a region.\r\\@deprecated\n */\nexport class FocusTrapDeprecatedDirective implements OnDestroy, AfterContentInit {\r\n  focusTrap: FocusTrap;\n/**\n * Whether the focus trap is active.\n * @return {?}\n */\nget disabled(): boolean { return !this.focusTrap.enabled; }\n/**\n * @param {?} val\n * @return {?}\n */\nset disabled(val: boolean) {\r\n    this.focusTrap.enabled = !coerceBooleanProperty(val);\r\n  }\n/**\n * @param {?} _elementRef\n * @param {?} _focusTrapFactory\n */\nconstructor(private _elementRef: ElementRef,\nprivate _focusTrapFactory: FocusTrapFactory) {\r\n    this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\r\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\r\n    this.focusTrap.destroy();\r\n  }\n/**\n * @return {?}\n */\nngAfterContentInit() {\r\n    this.focusTrap.attachAnchors();\r\n  }\r\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{\r\n  selector: 'cdk-focus-trap',\r\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ElementRef, },\n{type: FocusTrapFactory, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'disabled': [{ type: Input },],\n};\n}\n\nfunction FocusTrapDeprecatedDirective_tsickle_Closure_declarations() {\n/** @type {?} */\nFocusTrapDeprecatedDirective.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nFocusTrapDeprecatedDirective.ctorParameters;\n/** @type {?} */\nFocusTrapDeprecatedDirective.propDecorators;\n/** @type {?} */\nFocusTrapDeprecatedDirective.prototype.focusTrap;\n/** @type {?} */\nFocusTrapDeprecatedDirective.prototype._elementRef;\n/** @type {?} */\nFocusTrapDeprecatedDirective.prototype._focusTrapFactory;\n}\n\n/**\n * Directive for trapping focus within a region.\n */\nexport class FocusTrapDirective implements OnDestroy, AfterContentInit {\r\n  focusTrap: FocusTrap;\n/**\n * Whether the focus trap is active.\n * @return {?}\n */\nget enabled(): boolean { return this.focusTrap.enabled; }\n/**\n * @param {?} value\n * @return {?}\n */\nset enabled(value: boolean) { this.focusTrap.enabled = coerceBooleanProperty(value); }\n/**\n * @param {?} _elementRef\n * @param {?} _focusTrapFactory\n */\nconstructor(private _elementRef: ElementRef,\nprivate _focusTrapFactory: FocusTrapFactory) {\r\n    this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\r\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\r\n    this.focusTrap.destroy();\r\n  }\n/**\n * @return {?}\n */\nngAfterContentInit() {\r\n    this.focusTrap.attachAnchors();\r\n  }\r\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{\r\n  selector: '[cdkTrapFocus]',\r\n  exportAs: 'cdkTrapFocus',\r\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ElementRef, },\n{type: FocusTrapFactory, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'enabled': [{ type: Input, args: ['cdkTrapFocus', ] },],\n};\n}\n\nfunction FocusTrapDirective_tsickle_Closure_declarations() {\n/** @type {?} */\nFocusTrapDirective.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nFocusTrapDirective.ctorParameters;\n/** @type {?} */\nFocusTrapDirective.propDecorators;\n/** @type {?} */\nFocusTrapDirective.prototype.focusTrap;\n/** @type {?} */\nFocusTrapDirective.prototype._elementRef;\n/** @type {?} */\nFocusTrapDirective.prototype._focusTrapFactory;\n}\n\r\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {\r\n  Injectable,\r\n  InjectionToken,\r\n  Optional,\r\n  Inject,\r\n  SkipSelf,\r\n  OnDestroy,\r\n} from '@angular/core';\r\nimport {Platform} from '@angular/cdk/platform';\r\n\r\n\r\nexport const /** @type {?} */ LIVE_ANNOUNCER_ELEMENT_TOKEN = new InjectionToken<HTMLElement>('liveAnnouncerElement');\r\n\r\n/** Possible politeness levels. */\r\nexport type AriaLivePoliteness = 'off' | 'polite' | 'assertive';\nexport class LiveAnnouncer implements OnDestroy {\nprivate _liveElement: Element;\n/**\n * @param {?} elementToken\n * @param {?} platform\n */\nconstructor(\r\n        elementToken: any,\r\n      platform: Platform) {\r\n    // Only do anything if we're on the browser platform.\r\n    if (platform.isBrowser) {\r\n      // We inject the live element as `any` because the constructor signature cannot reference\r\n      // browser globals (HTMLElement) on non-browser environments, since having a class decorator\r\n      // causes TypeScript to preserve the constructor signature types.\r\n      this._liveElement = elementToken || this._createLiveElement();\r\n    }\r\n  }\n/**\n * Announces a message to screenreaders.\r\\@param message Message to be announced to the screenreader\r\\@param politeness The politeness of the announcer element\n * @param {?} message\n * @param {?=} politeness\n * @return {?}\n */\nannounce(message: string, politeness: AriaLivePoliteness = 'polite'): void {\r\n    this._liveElement.textContent = '';\r\n\r\n    // TODO: ensure changing the politeness works on all environments we support.\r\n    this._liveElement.setAttribute('aria-live', politeness);\r\n\r\n    // This 100ms timeout is necessary for some browser + screen-reader combinations:\r\n    // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\r\n    // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a\r\n    //   second time without clearing and then using a non-zero delay.\r\n    // (using JAWS 17 at time of this writing).\r\n    setTimeout(() => this._liveElement.textContent = message, 100);\r\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\r\n    if (this._liveElement && this._liveElement.parentNode) {\r\n      this._liveElement.parentNode.removeChild(this._liveElement);\r\n    }\r\n  }\n/**\n * @return {?}\n */\nprivate _createLiveElement(): Element {\r\n    let /** @type {?} */ liveEl = document.createElement('div');\r\n\r\n    liveEl.classList.add('cdk-visually-hidden');\r\n    liveEl.setAttribute('aria-atomic', 'true');\r\n    liveEl.setAttribute('aria-live', 'polite');\r\n\r\n    document.body.appendChild(liveEl);\r\n\r\n    return liveEl;\r\n  }\r\n\r\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LIVE_ANNOUNCER_ELEMENT_TOKEN, ] }, ]},\n{type: Platform, },\n];\n}\n\nfunction LiveAnnouncer_tsickle_Closure_declarations() {\n/** @type {?} */\nLiveAnnouncer.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nLiveAnnouncer.ctorParameters;\n/** @type {?} */\nLiveAnnouncer.prototype._liveElement;\n}\n\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} liveElement\n * @param {?} platform\n * @return {?}\n */\nexport function LIVE_ANNOUNCER_PROVIDER_FACTORY(\r\n    parentDispatcher: LiveAnnouncer, liveElement: any, platform: Platform) {\r\n  return parentDispatcher || new LiveAnnouncer(liveElement, platform);\r\n}\n/**\n * \\@docs-private\n */\nexport const LIVE_ANNOUNCER_PROVIDER = {\r\n  // If there is already a LiveAnnouncer available, use that. Otherwise, provide a new one.\r\n  provide: LiveAnnouncer,\r\n  deps: [\r\n    [new Optional(), new SkipSelf(), LiveAnnouncer],\r\n    [new Optional(), new Inject(LIVE_ANNOUNCER_ELEMENT_TOKEN)],\r\n    Platform,\r\n  ],\r\n  useFactory: LIVE_ANNOUNCER_PROVIDER_FACTORY\r\n};\r\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {Platform} from '@angular/cdk/platform';\r\nimport {\r\n  Directive,\r\n  ElementRef,\r\n  EventEmitter,\r\n  Injectable,\r\n  NgZone,\r\n  OnDestroy,\r\n  Optional,\r\n  Output,\r\n  Renderer2,\r\n  SkipSelf,\r\n} from '@angular/core';\r\nimport {Observable} from 'rxjs/Observable';\r\nimport {of as observableOf} from 'rxjs/observable/of';\r\nimport {Subject} from 'rxjs/Subject';\r\nimport {Subscription} from 'rxjs/Subscription';\r\n\r\n\r\n// This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\r\n// that a value of around 650ms seems appropriate.\r\nexport const /** @type {?} */ TOUCH_BUFFER_MS = 650;\r\n\r\n\r\nexport type FocusOrigin = 'touch' | 'mouse' | 'keyboard' | 'program' | null;\r\n\r\n\r\ntype MonitoredElementInfo = {\r\n  unlisten: Function,\r\n  checkChildren: boolean,\r\n  renderer: Renderer2,\r\n  subject: Subject<FocusOrigin>\r\n};\n/**\n * Monitors mouse and keyboard events to determine the cause of focus events.\n */\nexport class FocusMonitor {\n/**\n * The focus origin that the next focus event is a result of.\n */\nprivate _origin: FocusOrigin = null;\n/**\n * The FocusOrigin of the last focus event tracked by the FocusMonitor.\n */\nprivate _lastFocusOrigin: FocusOrigin;\n/**\n * Whether the window has just been focused.\n */\nprivate _windowFocused = false;\n/**\n * The target of the last touch event.\n */\nprivate _lastTouchTarget: EventTarget | null;\n/**\n * The timeout id of the touch timeout, used to cancel timeout later.\n */\nprivate _touchTimeout: number;\n/**\n * Weak map of elements being monitored to their info.\n */\nprivate _elementInfo = new WeakMap<Element, MonitoredElementInfo>();\n/**\n * @param {?} _ngZone\n * @param {?} _platform\n */\nconstructor(private _ngZone: NgZone,\nprivate _platform: Platform) {\r\n    this._ngZone.runOutsideAngular(() => this._registerDocumentEvents());\r\n  }\n/**\n * Monitors focus on an element and applies appropriate CSS classes.\r\\@param element The element to monitor\r\\@param renderer The renderer to use to apply CSS classes to the element.\r\\@param checkChildren Whether to count the element as focused when its children are focused.\r\\@returns An observable that emits when the focus state of the element changes.\r    When the element is blurred, null will be emitted.\n * @param {?} element\n * @param {?} renderer\n * @param {?} checkChildren\n * @return {?}\n */\nmonitor(\r\n      element: HTMLElement,\r\n      renderer: Renderer2,\r\n      checkChildren: boolean): Observable<FocusOrigin> {\r\n    // Do nothing if we're not on the browser platform.\r\n    if (!this._platform.isBrowser) {\r\n      return observableOf(null);\r\n    }\r\n    // Check if we're already monitoring this element.\r\n    if (this._elementInfo.has(element)) {\r\n      let /** @type {?} */ cachedInfo = this._elementInfo.get(element); /** @type {?} */((\r\n      cachedInfo)).checkChildren = checkChildren;\r\n      return /** @type {?} */(( cachedInfo)).subject.asObservable();\r\n    }\r\n\r\n    // Create monitored element info.\r\n    let /** @type {?} */ info: MonitoredElementInfo = {\r\n      unlisten: () => {},\r\n      checkChildren: checkChildren,\r\n      renderer: renderer,\r\n      subject: new Subject<FocusOrigin>()\r\n    };\r\n    this._elementInfo.set(element, info);\r\n\r\n    // Start listening. We need to listen in capture phase since focus events don't bubble.\r\n    let /** @type {?} */ focusListener = (event: FocusEvent) => this._onFocus(event, element);\r\n    let /** @type {?} */ blurListener = (event: FocusEvent) => this._onBlur(event, element);\r\n    this._ngZone.runOutsideAngular(() => {\r\n      element.addEventListener('focus', focusListener, true);\r\n      element.addEventListener('blur', blurListener, true);\r\n    });\r\n\r\n    // Create an unlisten function for later.\r\n    info.unlisten = () => {\r\n      element.removeEventListener('focus', focusListener, true);\r\n      element.removeEventListener('blur', blurListener, true);\r\n    };\r\n\r\n    return info.subject.asObservable();\r\n  }\n/**\n * Stops monitoring an element and removes all focus classes.\r\\@param element The element to stop monitoring.\n * @param {?} element\n * @return {?}\n */\nstopMonitoring(element: HTMLElement): void {\r\n    let /** @type {?} */ elementInfo = this._elementInfo.get(element);\r\n\r\n    if (elementInfo) {\r\n      elementInfo.unlisten();\r\n      elementInfo.subject.complete();\r\n\r\n      this._setClasses(element);\r\n      this._elementInfo.delete(element);\r\n    }\r\n  }\n/**\n * Focuses the element via the specified focus origin.\r\\@param element The element to focus.\r\\@param origin The focus origin.\n * @param {?} element\n * @param {?} origin\n * @return {?}\n */\nfocusVia(element: HTMLElement, origin: FocusOrigin): void {\r\n    this._setOriginForCurrentEventQueue(origin);\r\n    element.focus();\r\n  }\n/**\n * Register necessary event listeners on the document and window.\n * @return {?}\n */\nprivate _registerDocumentEvents() {\r\n    // Do nothing if we're not on the browser platform.\r\n    if (!this._platform.isBrowser) {\r\n      return;\r\n    }\r\n\r\n    // Note: we listen to events in the capture phase so we can detect them even if the user stops\r\n    // propagation.\r\n\r\n    // On keydown record the origin and clear any touch event that may be in progress.\r\n    document.addEventListener('keydown', () => {\r\n      this._lastTouchTarget = null;\r\n      this._setOriginForCurrentEventQueue('keyboard');\r\n    }, true);\r\n\r\n    // On mousedown record the origin only if there is not touch target, since a mousedown can\r\n    // happen as a result of a touch event.\r\n    document.addEventListener('mousedown', () => {\r\n      if (!this._lastTouchTarget) {\r\n        this._setOriginForCurrentEventQueue('mouse');\r\n      }\r\n    }, true);\r\n\r\n    // When the touchstart event fires the focus event is not yet in the event queue. This means\r\n    // we can't rely on the trick used above (setting timeout of 0ms). Instead we wait 650ms to\r\n    // see if a focus happens.\r\n    document.addEventListener('touchstart', (event: Event) => {\r\n      if (this._touchTimeout != null) {\r\n        clearTimeout(this._touchTimeout);\r\n      }\r\n      this._lastTouchTarget = event.target;\r\n      this._touchTimeout = setTimeout(() => this._lastTouchTarget = null, TOUCH_BUFFER_MS);\r\n    }, true);\r\n\r\n    // Make a note of when the window regains focus, so we can restore the origin info for the\r\n    // focused element.\r\n    window.addEventListener('focus', () => {\r\n      this._windowFocused = true;\r\n      setTimeout(() => this._windowFocused = false, 0);\r\n    });\r\n  }\n/**\n * Sets the focus classes on the element based on the given focus origin.\r\\@param element The element to update the classes on.\r\\@param origin The focus origin.\n * @param {?} element\n * @param {?=} origin\n * @return {?}\n */\nprivate _setClasses(element: HTMLElement, origin?: FocusOrigin): void {\r\n    const /** @type {?} */ elementInfo = this._elementInfo.get(element);\r\n\r\n    if (elementInfo) {\r\n      const /** @type {?} */ toggleClass = (className: string, shouldSet: boolean) => {\r\n        shouldSet ? elementInfo.renderer.addClass(element, className) :\r\n                    elementInfo.renderer.removeClass(element, className);\r\n      };\r\n\r\n      toggleClass('cdk-focused', !!origin);\r\n      toggleClass('cdk-touch-focused', origin === 'touch');\r\n      toggleClass('cdk-keyboard-focused', origin === 'keyboard');\r\n      toggleClass('cdk-mouse-focused', origin === 'mouse');\r\n      toggleClass('cdk-program-focused', origin === 'program');\r\n    }\r\n  }\n/**\n * Sets the origin and schedules an async function to clear it at the end of the event queue.\r\\@param origin The origin to set.\n * @param {?} origin\n * @return {?}\n */\nprivate _setOriginForCurrentEventQueue(origin: FocusOrigin): void {\r\n    this._origin = origin;\r\n    setTimeout(() => this._origin = null, 0);\r\n  }\n/**\n * Checks whether the given focus event was caused by a touchstart event.\r\\@param event The focus event to check.\r\\@returns Whether the event was caused by a touch.\n * @param {?} event\n * @return {?}\n */\nprivate _wasCausedByTouch(event: FocusEvent): boolean {\r\n    // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.\r\n    // Consider the following dom structure:\r\n    //\r\n    // <div #parent tabindex=\"0\" cdkFocusClasses>\r\n    //   <div #child (click)=\"#parent.focus()\"></div>\r\n    // </div>\r\n    //\r\n    // If the user touches the #child element and the #parent is programmatically focused as a\r\n    // result, this code will still consider it to have been caused by the touch event and will\r\n    // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a\r\n    // relatively small edge-case that can be worked around by using\r\n    // focusVia(parentEl, renderer,  'program') to focus the parent element.\r\n    //\r\n    // If we decide that we absolutely must handle this case correctly, we can do so by listening\r\n    // for the first focus event after the touchstart, and then the first blur event after that\r\n    // focus event. When that blur event fires we know that whatever follows is not a result of the\r\n    // touchstart.\r\n    let /** @type {?} */ focusTarget = event.target;\r\n    return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&\r\n        (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));\r\n  }\n/**\n * Handles focus events on a registered element.\r\\@param event The focus event.\r\\@param element The monitored element.\n * @param {?} event\n * @param {?} element\n * @return {?}\n */\nprivate _onFocus(event: FocusEvent, element: HTMLElement) {\r\n    // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\r\n    // focus event affecting the monitored element. If we want to use the origin of the first event\r\n    // instead we should check for the cdk-focused class here and return if the element already has\r\n    // it. (This only matters for elements that have includesChildren = true).\r\n\r\n    // If we are not counting child-element-focus as focused, make sure that the event target is the\r\n    // monitored element itself.\r\n    const /** @type {?} */ elementInfo = this._elementInfo.get(element);\r\n    if (!elementInfo || (!elementInfo.checkChildren && element !== event.target)) {\r\n      return;\r\n    }\r\n\r\n    // If we couldn't detect a cause for the focus event, it's due to one of three reasons:\r\n    // 1) The window has just regained focus, in which case we want to restore the focused state of\r\n    //    the element from before the window blurred.\r\n    // 2) It was caused by a touch event, in which case we mark the origin as 'touch'.\r\n    // 3) The element was programmatically focused, in which case we should mark the origin as\r\n    //    'program'.\r\n    if (!this._origin) {\r\n      if (this._windowFocused && this._lastFocusOrigin) {\r\n        this._origin = this._lastFocusOrigin;\r\n      } else if (this._wasCausedByTouch(event)) {\r\n        this._origin = 'touch';\r\n      } else {\r\n        this._origin = 'program';\r\n      }\r\n    }\r\n\r\n    this._setClasses(element, this._origin);\r\n    elementInfo.subject.next(this._origin);\r\n    this._lastFocusOrigin = this._origin;\r\n    this._origin = null;\r\n  }\n/**\n * Handles blur events on a registered element.\r\\@param event The blur event.\r\\@param element The monitored element.\n * @param {?} event\n * @param {?} element\n * @return {?}\n */\n_onBlur(event: FocusEvent, element: HTMLElement) {\r\n    // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\r\n    // order to focus another child of the monitored element.\r\n    const /** @type {?} */ elementInfo = this._elementInfo.get(element);\r\n\r\n    if (!elementInfo || (elementInfo.checkChildren && event.relatedTarget instanceof Node &&\r\n        element.contains(event.relatedTarget))) {\r\n      return;\r\n    }\r\n\r\n    this._setClasses(element);\r\n    elementInfo.subject.next(null);\r\n  }\r\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: NgZone, },\n{type: Platform, },\n];\n}\n\nfunction FocusMonitor_tsickle_Closure_declarations() {\n/** @type {?} */\nFocusMonitor.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nFocusMonitor.ctorParameters;\n/**\n * The focus origin that the next focus event is a result of.\n * @type {?}\n */\nFocusMonitor.prototype._origin;\n/**\n * The FocusOrigin of the last focus event tracked by the FocusMonitor.\n * @type {?}\n */\nFocusMonitor.prototype._lastFocusOrigin;\n/**\n * Whether the window has just been focused.\n * @type {?}\n */\nFocusMonitor.prototype._windowFocused;\n/**\n * The target of the last touch event.\n * @type {?}\n */\nFocusMonitor.prototype._lastTouchTarget;\n/**\n * The timeout id of the touch timeout, used to cancel timeout later.\n * @type {?}\n */\nFocusMonitor.prototype._touchTimeout;\n/**\n * Weak map of elements being monitored to their info.\n * @type {?}\n */\nFocusMonitor.prototype._elementInfo;\n/** @type {?} */\nFocusMonitor.prototype._ngZone;\n/** @type {?} */\nFocusMonitor.prototype._platform;\n}\n\n/**\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\rprogrammatically) and adds corresponding classes to the element.\r\rThere are two variants of this directive:\r1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\r   focused.\r2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\n */\nexport class CdkMonitorFocus implements OnDestroy {\nprivate _monitorSubscription: Subscription;\r\n   cdkFocusChange = new EventEmitter<FocusOrigin>();\n/**\n * @param {?} _elementRef\n * @param {?} _focusMonitor\n * @param {?} renderer\n */\nconstructor(private _elementRef: ElementRef,\nprivate _focusMonitor: FocusMonitor,\r\n              renderer: Renderer2) {\r\n    this._monitorSubscription = this._focusMonitor.monitor(\r\n        this._elementRef.nativeElement, renderer,\r\n        this._elementRef.nativeElement.hasAttribute('cdkMonitorSubtreeFocus'))\r\n        .subscribe(origin => this.cdkFocusChange.emit(origin));\r\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\r\n    this._focusMonitor.stopMonitoring(this._elementRef.nativeElement);\r\n    this._monitorSubscription.unsubscribe();\r\n  }\r\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{\r\n  selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',\r\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ElementRef, },\n{type: FocusMonitor, },\n{type: Renderer2, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'cdkFocusChange': [{ type: Output },],\n};\n}\n\nfunction CdkMonitorFocus_tsickle_Closure_declarations() {\n/** @type {?} */\nCdkMonitorFocus.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nCdkMonitorFocus.ctorParameters;\n/** @type {?} */\nCdkMonitorFocus.propDecorators;\n/** @type {?} */\nCdkMonitorFocus.prototype._monitorSubscription;\n/** @type {?} */\nCdkMonitorFocus.prototype.cdkFocusChange;\n/** @type {?} */\nCdkMonitorFocus.prototype._elementRef;\n/** @type {?} */\nCdkMonitorFocus.prototype._focusMonitor;\n}\n\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} ngZone\n * @param {?} platform\n * @return {?}\n */\nexport function FOCUS_MONITOR_PROVIDER_FACTORY(\r\n    parentDispatcher: FocusMonitor, ngZone: NgZone, platform: Platform) {\r\n  return parentDispatcher || new FocusMonitor(ngZone, platform);\r\n}\n/**\n * \\@docs-private\n */\nexport const FOCUS_MONITOR_PROVIDER = {\r\n  // If there is already a FocusMonitor available, use that. Otherwise, provide a new one.\r\n  provide: FocusMonitor,\r\n  deps: [[new Optional(), new SkipSelf(), FocusMonitor], NgZone, Platform],\r\n  useFactory: FOCUS_MONITOR_PROVIDER_FACTORY\r\n};\r\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {QueryList} from '@angular/core';\r\nimport {Subject} from 'rxjs/Subject';\r\nimport {Subscription} from 'rxjs/Subscription';\r\nimport {UP_ARROW, DOWN_ARROW, TAB, A, Z, ZERO, NINE} from '@angular/cdk/keycodes';\r\nimport {RxChain, debounceTime, filter, map, doOperator} from '@angular/cdk/rxjs';\r\n\r\n/**\r\n * This interface is for items that can be passed to a ListKeyManager.\r\n */\r\nexport interface ListKeyManagerOption {\r\n  disabled?: boolean;\r\n  getLabel?(): string;\r\n}\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\rof items, it will set the active item correctly when arrow events occur.\n */\nexport class ListKeyManager<T extends ListKeyManagerOption> {\nprivate _activeItemIndex = -1;\nprivate _activeItem: T;\nprivate _wrap = false;\nprivate _letterKeyStream = new Subject<string>();\nprivate _typeaheadSubscription = Subscription.EMPTY;\nprivate _pressedLetters: string[] = [];\n/**\n * @param {?} _items\n */\nconstructor(private _items: QueryList<T>) { }\n/**\n * Stream that emits any time the TAB key is pressed, so components can react\rwhen focus is shifted off of the list.\n */\ntabOut: Subject<void> = new Subject<void>();\n/**\n * Turns on wrapping mode, which ensures that the active item will wrap to\rthe other end of list when there are no more items in the given direction.\n * @return {?}\n */\nwithWrap(): this {\r\n    this._wrap = true;\r\n    return this;\r\n  }\n/**\n * Turns on typeahead mode which allows users to set the active item by typing.\r\\@param debounceInterval Time to wait after the last keystroke before setting the active item.\n * @param {?=} debounceInterval\n * @return {?}\n */\nwithTypeAhead(debounceInterval = 200): this {\r\n    if (this._items.length && this._items.some(item => typeof item.getLabel !== 'function')) {\r\n      throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\r\n    }\r\n\r\n    this._typeaheadSubscription.unsubscribe();\r\n\r\n    // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\r\n    // and convert those letters back into a string. Afterwards find the first item that starts\r\n    // with that string and select it.\r\n    this._typeaheadSubscription = RxChain.from(this._letterKeyStream)\r\n      .call(doOperator, keyCode => this._pressedLetters.push(keyCode))\r\n      .call(debounceTime, debounceInterval)\r\n      .call(filter, () => this._pressedLetters.length > 0)\r\n      .call(map, () => this._pressedLetters.join(''))\r\n      .subscribe(inputString => {\r\n        const /** @type {?} */ items = this._items.toArray();\r\n\r\n        for (let /** @type {?} */ i = 0; i < items.length; i++) {\r\n          if ( /** @type {?} */((items[i].getLabel))().toUpperCase().trim().indexOf(inputString) === 0) {\r\n            this.setActiveItem(i);\r\n            break;\r\n          }\r\n        }\r\n\r\n        this._pressedLetters = [];\r\n      });\r\n\r\n    return this;\r\n  }\n/**\n * Sets the active item to the item at the index specified.\r\\@param index The index of the item to be set as active.\n * @param {?} index\n * @return {?}\n */\nsetActiveItem(index: number): void {\r\n    this._activeItemIndex = index;\r\n    this._activeItem = this._items.toArray()[index];\r\n  }\n/**\n * Sets the active item depending on the key event passed in.\r\\@param event Keyboard event to be used for determining which element should be active.\n * @param {?} event\n * @return {?}\n */\nonKeydown(event: KeyboardEvent): void {\r\n    switch (event.keyCode) {\r\n      case DOWN_ARROW: this.setNextItemActive(); break;\r\n      case UP_ARROW: this.setPreviousItemActive(); break;\r\n      case TAB: this.tabOut.next(); return;\r\n      default:\r\n        const /** @type {?} */ keyCode = event.keyCode;\r\n\r\n        // Attempt to use the `event.key` which also maps it to the user's keyboard language,\r\n        // otherwise fall back to resolving alphanumeric characters via the keyCode.\r\n        if (event.key && event.key.length === 1) {\r\n          this._letterKeyStream.next(event.key.toLocaleUpperCase());\r\n        } else if ((keyCode >= A && keyCode <= Z) || (keyCode >= ZERO && keyCode <= NINE)) {\r\n          this._letterKeyStream.next(String.fromCharCode(keyCode));\r\n        }\r\n\r\n        // Note that we return here, in order to avoid preventing\r\n        // the default action of non-navigational keys.\r\n        return;\r\n    }\r\n\r\n    this._pressedLetters = [];\r\n    event.preventDefault();\r\n  }\n/**\n * Index of the currently active item.\n * @return {?}\n */\nget activeItemIndex(): number | null {\r\n    return this._activeItemIndex;\r\n  }\n/**\n * The active item.\n * @return {?}\n */\nget activeItem(): T | null {\r\n    return this._activeItem;\r\n  }\n/**\n * Sets the active item to the first enabled item in the list.\n * @return {?}\n */\nsetFirstItemActive(): void {\r\n    this._setActiveItemByIndex(0, 1);\r\n  }\n/**\n * Sets the active item to the last enabled item in the list.\n * @return {?}\n */\nsetLastItemActive(): void {\r\n    this._setActiveItemByIndex(this._items.length - 1, -1);\r\n  }\n/**\n * Sets the active item to the next enabled item in the list.\n * @return {?}\n */\nsetNextItemActive(): void {\r\n    this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\r\n  }\n/**\n * Sets the active item to a previous enabled item in the list.\n * @return {?}\n */\nsetPreviousItemActive(): void {\r\n    this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive()\r\n                                            : this._setActiveItemByDelta(-1);\r\n  }\n/**\n * Allows setting of the activeItemIndex without any other effects.\r\\@param index The new activeItemIndex.\n * @param {?} index\n * @return {?}\n */\nupdateActiveItemIndex(index: number) {\r\n    this._activeItemIndex = index;\r\n  }\n/**\n * This method sets the active item, given a list of items and the delta between the\rcurrently active item and the new active item. It will calculate differently\rdepending on whether wrap mode is turned on.\n * @param {?} delta\n * @param {?=} items\n * @return {?}\n */\nprivate _setActiveItemByDelta(delta: number, items = this._items.toArray()): void {\r\n    this._wrap ? this._setActiveInWrapMode(delta, items)\r\n               : this._setActiveInDefaultMode(delta, items);\r\n  }\n/**\n * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\rdown the list until it finds an item that is not disabled, and it will wrap if it\rencounters either end of the list.\n * @param {?} delta\n * @param {?} items\n * @return {?}\n */\nprivate _setActiveInWrapMode(delta: number, items: T[]): void {\r\n    // when active item would leave menu, wrap to beginning or end\r\n    this._activeItemIndex =\r\n      (this._activeItemIndex + delta + items.length) % items.length;\r\n\r\n    // skip all disabled menu items recursively until an enabled one is reached\r\n    if (items[this._activeItemIndex].disabled) {\r\n      this._setActiveInWrapMode(delta, items);\r\n    } else {\r\n      this.setActiveItem(this._activeItemIndex);\r\n    }\r\n  }\n/**\n * Sets the active item properly given the default mode. In other words, it will\rcontinue to move down the list until it finds an item that is not disabled. If\rit encounters either end of the list, it will stop and not wrap.\n * @param {?} delta\n * @param {?} items\n * @return {?}\n */\nprivate _setActiveInDefaultMode(delta: number, items: T[]): void {\r\n    this._setActiveItemByIndex(this._activeItemIndex + delta, delta, items);\r\n  }\n/**\n * Sets the active item to the first enabled item starting at the index specified. If the\ritem is disabled, it will move in the fallbackDelta direction until it either\rfinds an enabled item or encounters the end of the list.\n * @param {?} index\n * @param {?} fallbackDelta\n * @param {?=} items\n * @return {?}\n */\nprivate _setActiveItemByIndex(index: number, fallbackDelta: number,\r\n                                  items = this._items.toArray()): void {\r\n    if (!items[index]) { return; }\r\n    while (items[index].disabled) {\r\n      index += fallbackDelta;\r\n      if (!items[index]) { return; }\r\n    }\r\n    this.setActiveItem(index);\r\n  }\r\n}\n\nfunction ListKeyManager_tsickle_Closure_declarations() {\n/** @type {?} */\nListKeyManager.prototype._activeItemIndex;\n/** @type {?} */\nListKeyManager.prototype._activeItem;\n/** @type {?} */\nListKeyManager.prototype._wrap;\n/** @type {?} */\nListKeyManager.prototype._letterKeyStream;\n/** @type {?} */\nListKeyManager.prototype._typeaheadSubscription;\n/** @type {?} */\nListKeyManager.prototype._pressedLetters;\n/**\n * Stream that emits any time the TAB key is pressed, so components can react\rwhen focus is shifted off of the list.\n * @type {?}\n */\nListKeyManager.prototype.tabOut;\n/** @type {?} */\nListKeyManager.prototype._items;\n}\n\r\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {ListKeyManager, ListKeyManagerOption} from './list-key-manager';\r\n\r\n/**\r\n * This is the interface for highlightable items (used by the ActiveDescendantKeyManager).\r\n * Each item must know how to style itself as active or inactive and whether or not it is\r\n * currently disabled.\r\n */\r\nexport interface Highlightable extends ListKeyManagerOption {\r\n  setActiveStyles(): void;\r\n  setInactiveStyles(): void;\r\n}\nexport class ActiveDescendantKeyManager<T> extends ListKeyManager<Highlightable & T> {\n/**\n * This method sets the active item to the item at the specified index.\rIt also adds active styles to the newly active item and removes active\rstyles from the previously active item.\n * @param {?} index\n * @return {?}\n */\nsetActiveItem(index: number): void {\r\n    Promise.resolve().then(() => {\r\n      if (this.activeItem) {\r\n        this.activeItem.setInactiveStyles();\r\n      }\r\n      super.setActiveItem(index);\r\n      if (this.activeItem) {\r\n        this.activeItem.setActiveStyles();\r\n      }\r\n    });\r\n  }\r\n\r\n}\r\n","\n/**\n * Screenreaders will often fire fake mousedown events when a focusable element\ris activated using the keyboard. We can typically distinguish between these faked\rmousedown events and real mousedown events using the \"buttons\" property. While\rreal mousedowns will indicate the mouse button that was pressed (e.g. \"1\" for\rthe left mouse button), faked mousedowns will usually set the property value to 0.\n * @param {?} event\n * @return {?}\n */\nexport function isFakeMousedownFromScreenReader(event: MouseEvent): boolean {\r\n  return event.buttons === 0;\r\n}\r\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {ListKeyManager, ListKeyManagerOption} from './list-key-manager';\r\n\r\n/**\r\n * This is the interface for focusable items (used by the FocusKeyManager).\r\n * Each item must know how to focus itself, whether or not it is currently disabled\r\n * and be able to supply it's label.\r\n */\r\nexport interface FocusableOption extends ListKeyManagerOption {\r\n  focus(): void;\r\n}\nexport class FocusKeyManager<T> extends ListKeyManager<FocusableOption & T> {\n/**\n * This method sets the active item to the item at the specified index.\rIt also adds focuses the newly active item.\n * @param {?} index\n * @return {?}\n */\nsetActiveItem(index: number): void {\r\n    super.setActiveItem(index);\r\n\r\n    if (this.activeItem) {\r\n      this.activeItem.focus();\r\n    }\r\n  }\r\n}\r\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\nimport {NgModule} from '@angular/core';\r\nimport {FocusTrapDeprecatedDirective, FocusTrapDirective, FocusTrapFactory} from './focus-trap';\r\nimport {LIVE_ANNOUNCER_PROVIDER} from './live-announcer';\r\nimport {InteractivityChecker} from './interactivity-checker';\r\nimport {CommonModule} from '@angular/common';\r\nimport {PlatformModule} from '@angular/cdk/platform';\r\nimport {AriaDescriber, ARIA_DESCRIBER_PROVIDER} from './aria-describer';\r\nimport {CdkMonitorFocus, FOCUS_MONITOR_PROVIDER} from './focus-monitor';\nexport class A11yModule {static decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{\r\n  imports: [CommonModule, PlatformModule],\r\n  declarations: [FocusTrapDirective, FocusTrapDeprecatedDirective, CdkMonitorFocus],\r\n  exports: [FocusTrapDirective, FocusTrapDeprecatedDirective, CdkMonitorFocus],\r\n  providers: [\r\n    InteractivityChecker,\r\n    FocusTrapFactory,\r\n    AriaDescriber,\r\n    LIVE_ANNOUNCER_PROVIDER,\r\n    ARIA_DESCRIBER_PROVIDER,\r\n    FOCUS_MONITOR_PROVIDER,\r\n  ]\r\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction A11yModule_tsickle_Closure_declarations() {\n/** @type {?} */\nA11yModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nA11yModule.ctorParameters;\n}\n\r\n\r\nexport {Highlightable,ActiveDescendantKeyManager} from './activedescendant-key-manager';\r\nexport {RegisteredMessage,MESSAGES_CONTAINER_ID,CDK_DESCRIBEDBY_ID_PREFIX,CDK_DESCRIBEDBY_HOST_ATTRIBUTE,AriaDescriber,ARIA_DESCRIBER_PROVIDER_FACTORY,ARIA_DESCRIBER_PROVIDER} from './aria-describer';\r\nexport {isFakeMousedownFromScreenReader} from './fake-mousedown';\r\nexport {FocusableOption,FocusKeyManager} from './focus-key-manager';\r\nexport {FocusTrap,FocusTrapFactory,FocusTrapDeprecatedDirective,FocusTrapDirective} from './focus-trap';\r\nexport {InteractivityChecker} from './interactivity-checker';\r\nexport {ListKeyManagerOption,ListKeyManager} from './list-key-manager';\r\nexport {LIVE_ANNOUNCER_ELEMENT_TOKEN,AriaLivePoliteness,LiveAnnouncer,LIVE_ANNOUNCER_PROVIDER_FACTORY,LIVE_ANNOUNCER_PROVIDER} from './live-announcer';\r\nexport {TOUCH_BUFFER_MS,FocusOrigin,FocusMonitor,CdkMonitorFocus,FOCUS_MONITOR_PROVIDER_FACTORY,FOCUS_MONITOR_PROVIDER} from './focus-monitor';\r\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"],"names":["__extends","d","b","__","this","constructor","extendStatics","prototype","Object","create","element","offsetWidth","offsetHeight","getClientRects","length","isNativeFormElement","nodeName","toLowerCase","isHiddenInput","isInputElement","type","isAnchorWithHref","isAnchorElement","hasAttribute","hasValidTabIndex","undefined","tabIndex","isNaN","parseInt","getTabIndexValue","getAttribute","isPotentiallyTabbableIOS","inputType","getWindow","node","ownerDocument","defaultView","window","ids","push","id","trim","getAriaReferenceIds","el","attr","messagesContainer","createMessagesContainer","appendChild","messageElement","messageRegistry","set","message","referenceCount","deleteMessageElement","registeredMessage","get","document","createElement","setAttribute","MESSAGES_CONTAINER_ID","deleteMessagesContainer","originalReferenceIds","join","addAriaReferencedId","CDK_DESCRIBEDBY_HOST_ATTRIBUTE","removeAriaReferencedId","isElementDescribedByMessage","referenceIds","messageId","setPrototypeOf","__proto__","Array","p","hasOwnProperty","InteractivityChecker","_platform","isDisabled","isVisible","hasGeometry","getComputedStyle","visibility","isTabbable","isBrowser","frameElement","frameType","BLINK","WEBKIT","tabIndexValue","TRIDENT","FIREFOX","IOS","isFocusable","isPotentiallyFocusable","decorators","Injectable","ctorParameters","Platform","FocusTrap","_element","_checker","_ngZone","deferAnchors","_enabled","val","_startAnchor","_endAnchor","destroy","parentNode","removeChild","attachAnchors","_this","_createAnchor","runOutsideAngular","addEventListener","focusLastTabbableElement","focusFirstTabbableElement","_getRegionBoundary","bound","markers","querySelectorAll","i","console","warn","_getLastTabbableElement","redirectToElement","focus","_getFirstTabbableElement","root","children","childNodes","tabbableChild","anchor","classList","add","_executeOnStable","fn","FocusTrapFactory","NgZone","_focusTrapFactory","focusTrap","_elementRef","nativeElement","enabled","coerceBooleanProperty","enumerable","configurable","FocusTrapDeprecatedDirective","ngAfterContentInit","Directive","args","ElementRef","value","FocusTrapDirective","ngOnDestroy","exportAs","_liveElement","elementToken","_createLiveElement","politeness","textContent","setTimeout","LiveAnnouncer","liveEl","body","Optional","Inject","LIVE_ANNOUNCER_ELEMENT_TOKEN","LIVE_ANNOUNCER_PROVIDER","provide","deps","SkipSelf","AriaDescriber","describe","hostElement","has","createMessageElement","addMessageReference","removeDescription","removeMessageReference","clear","ARIA_DESCRIBER_PROVIDER","_origin","_windowFocused","_elementInfo","WeakMap","_registerDocumentEvents","FocusMonitor","monitor","renderer","checkChildren","of","cachedInfo","subject","Subject","info","focusListener","event","_onFocus","blurListener","_onBlur","elementInfo","unlisten","complete","_setClasses","focusVia","origin","_setOriginForCurrentEventQueue","_lastTouchTarget","_touchTimeout","clearTimeout","target","_lastFocusOrigin","_wasCausedByTouch","next","contains","relatedTarget","CdkMonitorFocus","_focusMonitor","cdkFocusChange","EventEmitter","stopMonitoring","_monitorSubscription","unsubscribe","selector","Renderer2","useFactory","FOCUS_MONITOR_PROVIDER_FACTORY","ListKeyManager","_items","_activeItemIndex","_wrap","_letterKeyStream","tabOut","withWrap","some","item","getLabel","Error","_typeaheadSubscription","call","filter","_pressedLetters","map","subscribe","inputString","items","toArray","toUpperCase","indexOf","setActiveItem","index","DOWN_ARROW","setNextItemActive","key","toLocaleUpperCase","keyCode","A","Z","ZERO","NINE","defineProperty","setLastItemActive","setPreviousItemActive","_setActiveItemByDelta","_setActiveInWrapMode","delta","disabled","_setActiveInDefaultMode","_setActiveItemByIndex","fallbackDelta","ActiveDescendantKeyManager","_super","apply","arguments","tslib_1.__extends","Promise","resolve","then","activeItem","setInactiveStyles","setActiveStyles"],"mappings":"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"}